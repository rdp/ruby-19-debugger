Adds a frame object which gives dynamic information about a call-stack frame. From this we have access
to lots of low-level run-time information:

* the instruction sequence
* parameter arguments
* local variable information
* stack data information (sp)
* current program counter location (PC)
* previous frame

diff --git a/common.mk b/common.mk
index cb9b47b..1b14ce2 100644
--- a/common.mk
+++ b/common.mk
@@ -95,6 +95,7 @@ COMMONOBJS    = array.$(OBJEXT) \
 		vm_backtrace.$(OBJEXT) \
 		vm_trace.$(OBJEXT) \
 		thread.$(OBJEXT) \
+		frame.$(OBJEXT) \
 		cont.$(OBJEXT) \
 		$(BUILTIN_ENCOBJS) \
 		$(BUILTIN_TRANSOBJS) \
diff --git a/frame.c b/frame.c
new file mode 100644
index 0000000..95dd97b
--- /dev/null
+++ b/frame.c
@@ -0,0 +1,1133 @@
+/*
+ * Copyright (C) 2012, 2014-2015 Rocky Bernstein
+ *
+ *  Access to Ruby's rb_control_frame_t and methods for working with that.
+ *  Things like getting a binding for a control frame. In Ruby 1.9.2 this code
+ *  was in extension rb-threadframe
+ */
+
+#include "ruby/ruby.h"
+#include "vm_core.h"
+#include <string.h>
+#include <signal.h>
+
+#include <ruby.h>
+#if   defined(_WIN32)
+#include "thread_win32.h"
+#elif defined(HAVE_PTHREAD_H)
+#include "thread_pthread.h"
+#else
+#error "unsupported thread type"
+#endif
+#include "node.h"
+#include "gc.h"
+#include "iseq.h"
+
+RUBY_EXTERN rb_control_frame_t *
+thread_control_frame(rb_thread_t *th)
+{
+  if (th == NULL || ((VALUE) th) == Qnil)
+    th = GET_THREAD(); /* main thread */
+  return rb_vm_get_ruby_level_next_cfp(th, th->cfp);
+}
+
+
+/* Frames can't be detached from the control frame they live in.
+   So we create a structure to contain the pair.
+
+   The signature fields are used to weakly verify the validity of cfp.
+   it stores to contents of fields in cfp on allocation.  This, the
+   validity of "th" pointing to a valid thread, and cfp pointing to valid
+   location inside the frame area we use to check that this structure
+   is valid. */
+
+typedef struct
+{
+    rb_thread_t *th;
+    rb_control_frame_t *cfp;
+    VALUE *signature1[3]; /* iseq, flag, self */
+    VALUE *signature2[1]; /* proc */
+} thread_frame_t;
+
+VALUE rb_cFrame;       /* RubyVM::Frame class */
+VALUE rb_eFrameError;  /* Error raised on invalid frames. */
+
+/* Static forward declarations */
+VALUE rb_frame_iseq(VALUE klass);
+VALUE frame_prev(rb_control_frame_t *prev_cfp,
+		 rb_thread_t *th, int n);
+
+static int   frame_stack_size(rb_control_frame_t *cfp,
+			      rb_thread_t *th);
+static VALUE rb_frame_type(VALUE klass);
+
+
+extern void iseq_mark(void *ptr); /* in iseq.c */
+
+/*
+  FIXME: I've never seen the following routine get called.
+  Why?
+ */
+static void
+frame_mark(void *ptr)
+{
+    RUBY_MARK_ENTER("thread_frame");
+    if (ptr) {
+	thread_frame_t *tf = ptr;
+	if (tf && tf->cfp && RUBY_VM_NORMAL_ISEQ_P(tf->cfp->iseq)) {
+	    iseq_mark(tf->cfp->iseq);
+	}
+    }
+}
+
+static void
+tf_free(void *ptr)
+{
+    thread_frame_t *tf;
+    if (ptr) {
+	tf = ptr;
+	/* All valid frame types have 0x1 set so we will use this.
+	   Warning: this is an undocumented assumption which may someday
+	   be wrong. */
+	if (tf->cfp && ((tf->cfp->flag & 0x1) == 0) &&
+	    RUBY_VM_NORMAL_ISEQ_P(tf->cfp->iseq))
+	    tf->cfp->iseq->in_use--;
+	xfree(ptr);
+    }
+}
+
+/*
+   Allocate a RubyVM::Frame used by new. Less common than
+   thread_frame_t_alloc(). The caller is responsible for filling in
+   the C struct data. Below we wrap NULL.
+ */
+static VALUE
+frame_alloc(VALUE klass)
+{
+    return Data_Wrap_Struct(klass, frame_mark, tf_free, NULL);
+}
+
+/*
+   Allocate a RubyVM::Frame and set its threadframe structure.
+   This is the more common allocate routine since one normally doesn't
+   create a threadframe without <i>first</i> having something to put in it.
+ */
+static thread_frame_t *
+frame_t_alloc(VALUE tfval)
+{
+    thread_frame_t *tf = ALLOC(thread_frame_t);
+    memset(tf, 0, sizeof(thread_frame_t));
+    DATA_PTR(tfval) = tf;
+    return tf;
+}
+
+/*
+   Check to see if tf is valid. +true+ is returned if we can't prove
+   the frame is invalid. +nil+ or +false+ is returned if something is not
+   right. In those cases where we don't know that we have a valid frame,
+   we also NULL out the cfp if that hasn't been done already. This will
+   keep garbage collection from marking bad data.
+ */
+static VALUE
+frame_valid(thread_frame_t *tf)
+{
+    int cmp;
+
+    /* All valid frame types have 0x1 set so we will use this.
+       Warning: this is an undocumented assumption which may someday
+       be wrong. */
+    if (!tf->cfp) return Qtrue;
+    if ((tf->cfp->flag & 0x1) == 0) {
+	tf->cfp = NULL;
+	return Qfalse;
+    }
+
+    if (RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P(tf->th, tf->cfp)) {
+	tf->cfp = NULL;
+	return Qfalse;
+    }
+    if (RUBY_VM_NORMAL_ISEQ_P(tf->cfp->iseq)) {
+	cmp = (0 == memcmp(tf->signature1, &(tf->cfp->iseq),
+			   sizeof(tf->signature1)) &&
+	       0 == memcmp(tf->signature2, &(tf->cfp->proc),
+			   sizeof(tf->signature2)));
+	if (cmp) return Qtrue;
+	tf->cfp = NULL;
+	return Qfalse;
+    } else {
+	/* FIXME: figure out what to do here. In particular what to do
+	   for C functions.
+	*/
+	return Qtrue;
+    }
+}
+
+/*
+   COPY_SIGNATURE saves some invariant data from the frame for
+   comparison later when the frame is used again.
+
+   Even though fields like iseq may not be valid for things C function
+   frames, nevertheless all we care about is whether they could change
+   or not over the course of evaluation. Hving more data to compare
+   against to verify whether a frame is valid is helpful. If the data
+   is random unitialized data, that's even better. Again just so long as
+   that random data doesn't change in the course of normal use.
+
+   FIXME: There are probably more fields which could be saved.  */
+#define COPY_SIGNATURE(tf, cfp)					  \
+    memcpy(tf->signature1, &(cfp->iseq), sizeof(tf->signature1)); \
+    memcpy(tf->signature2, &(cfp->proc), sizeof(tf->signature2))
+
+#define SAVE_FRAME(TF, TH)						\
+    tf->th = TH;							\
+    tf->cfp = thread_control_frame(tf->th);				\
+    COPY_SIGNATURE(tf, tf->cfp);					\
+
+/*    tf->cfp->iseq->in_use++;						\ */
+
+#define GET_THREAD_PTR \
+    rb_thread_t *th; \
+    GetThreadPtr(thval, th)
+
+
+#define FRAME_SETUP \
+    thread_frame_t *tf; \
+    Data_Get_Struct(klass, thread_frame_t, tf)
+
+#define FRAME_SETUP_WITH_ERROR			    \
+    FRAME_SETUP;				    \
+    if (Qtrue != frame_valid(tf)) \
+	rb_raise(rb_eFrameError, "invalid frame")
+
+#define FRAME_FIELD_METHOD(FIELD)	\
+static VALUE					\
+rb_frame_##FIELD(VALUE klass)		\
+{						\
+    FRAME_SETUP ;			\
+    return tf->cfp->FIELD;			\
+}
+
+#define FRAME_FP_METHOD(REG)				\
+VALUE						                \
+rb_frame_##REG(VALUE klass, VALUE index)			\
+{								\
+    if (!FIXNUM_P(index)) {					\
+	rb_raise(rb_eTypeError, "integer argument expected");	\
+    } else {							\
+        long int i = FIX2INT(index);				\
+	FRAME_SETUP_WITH_ERROR ;					\
+	/* FIXME: check index is within range. */		\
+	return tf->cfp->REG[-i]; /* stack  grows "down" */	\
+    }								\
+}
+
+#if 0
+VALUE
+frame_sp(VALUE klass, VALUE index)
+{
+    /* handled by THREAD_FRAME_FP_METHOD macro;  */
+}
+#endif
+/*
+ *  call-seq:
+ *     RubyVM::Frame#sp(n)  -> object
+ *
+ * Returns a RubyVM object stored at stack position <i>i</i>. The top object
+ * is position 0. 1 is the next object.
+ */
+/* The above declaration is to make RDOC happy.
+   FIXME: Figure out a way to check if "index" is valid!
+*/
+FRAME_FP_METHOD(sp)
+
+/*
+ *  call-seq:
+ *     RubyVM::Frame#ep  -> object
+ *
+ * Returns a RubyVM object stored at ep.
+ */
+VALUE
+rb_frame_ep(VALUE klass)
+{
+    FRAME_SETUP_WITH_ERROR ;
+    return *(tf->cfp->ep);
+}
+
+static long int
+frame_sp_size(thread_frame_t *tf)
+{
+    rb_control_frame_t *prev_cfp;
+    long int ret_val;
+    prev_cfp = RUBY_VM_PREVIOUS_CONTROL_FRAME(tf->cfp);
+    if (RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P(tf->th, prev_cfp))
+	return Qnil;
+    ret_val = tf->cfp->sp - prev_cfp->sp - 1;
+    /* FIXME: Why For C Functions we tack on 2 for this RubyVM::ENV? */
+    if (RUBYVM_CFUNC_FRAME_P(tf->cfp)) ret_val += 2;
+    return ret_val;
+}
+
+/*
+ *  call-seq:
+ *     RubyVM::Frame#sp_size  -> FixNum
+ *
+ * Returns the number of stack or sp entries in the current
+ * frame. That is the, number values that have been pushed onto the
+ * stack since the current call.  This is different than
+ * RubyVM::Frame#stack_size which counts the number of frames in
+ * the call stack. +nil+ is returned if there is an error.
+ */
+VALUE
+rb_frame_sp_size(VALUE klass)
+{
+    FRAME_SETUP_WITH_ERROR ;
+    return INT2FIX(frame_sp_size(tf));
+}
+
+/*
+ *  call-seq:
+ *     RubyVM::Frame#sp_set(n, newvalue)  -> object
+ *
+ * Sets VM stack position <i>n</i> to <i>newvalue</i>. The top object
+ * is position 0. 1 is the next object.
+ */
+static VALUE
+rb_frame_sp_set(VALUE klass, VALUE index, VALUE newvalue)
+{
+    if (!FIXNUM_P(index)) {
+	rb_raise(rb_eTypeError, "integer argument expected");
+    } else {
+        long int i = FIX2INT(index);
+	FRAME_SETUP_WITH_ERROR ;
+	if (i <= frame_sp_size(tf)) {
+	    /* stack  grows "down" */
+	    tf->cfp->sp[-i] = newvalue;
+	} else {
+	    rb_raise(rb_eArgError, "argument too big");
+	}
+	return newvalue;
+    }
+}
+
+/*
+ *  call-seq:
+ *     RubyVM::Frame#pc_offset=
+ *
+ * Sets pc to the offset given.
+ * WARNING, this is pretty dangerous. You need to set this to a valid
+ * instruction offset since little checking is done.
+ */
+VALUE
+frame_set_pc_offset(VALUE klass, VALUE offset_val)
+{
+    int offset;
+    FRAME_SETUP_WITH_ERROR ;
+
+    if (!FIXNUM_P(offset_val)) {
+	rb_raise(rb_eTypeError, "integer argument expected");
+    } else {
+        offset = FIX2INT(offset_val);
+	if (RUBY_VM_NORMAL_ISEQ_P(tf->cfp->iseq) &&
+	    (tf->cfp->pc != 0 && tf->cfp->iseq != 0)) {
+            tf->cfp->pc = tf->cfp->iseq->iseq_encoded + offset;
+	}
+    }
+    return Qtrue;
+}
+
+/*
+ *  call-seq:
+ *     RubyVM::Frame#flag -> Fixnum
+ *
+ *  Returns the frame flags, a FIXNUM which should be interpreted as a
+ *  bitmask.
+ *
+ */
+#if 0
+/*
+ *  call-seq:
+ *     RubyVM::Frame#flag -> Fixnum
+ *
+ *  Returns the frame flags, a FIXNUM which should be interpreted as a
+ *  bitmask.
+ *
+ */
+static VALUE rb_frame_flag(VALUE klass)
+{
+    /* handled by FRAME_FIELD_METHOD macro;  */
+}
+/* The above declaration is to make RDOC happy. */
+#endif
+FRAME_FIELD_METHOD(flag) ;
+
+/*
+ *  call-seq:
+ *     RubyVM::Frame#binding   -> binding
+ *
+ *  Returns a binding for a given thread frame.
+ */
+VALUE
+rb_frame_binding(VALUE klass)
+{
+    FRAME_SETUP_WITH_ERROR ;
+
+    {
+	rb_binding_t *bind = 0;
+	VALUE bindval = rb_binding_frame_new(tf->th, tf->cfp);
+	GetBindingPtr(bindval, bind);
+	/* bind->line_no = rb_vm_get_sourceline(tf->cfp); */
+	if (tf->cfp->iseq) {
+	    bind->path = tf->cfp->iseq->location.path;
+	} else {
+	    bind->path = tf->th->vm->progname;
+	}
+	return bindval;
+    }
+    /* NOTREACHED */
+    return Qnil;
+}
+
+/*
+ *  call-seq:
+ *     RubyVM::Frame#equal(tf)   -> bool
+ *
+ *  Returns true if two thread frames are equal.
+ */
+static VALUE
+frame_equal(VALUE klass, VALUE tfval2)
+{
+    FRAME_SETUP ;
+
+    {
+	thread_frame_t *tf2;
+	if (!rb_obj_is_kind_of(tfval2, rb_cFrame)) {
+	rb_raise(rb_eTypeError,
+		 "comparison argument must be an instance of %s (is %s)",
+		 rb_obj_classname(klass), rb_obj_classname(tfval2));
+	}
+	Data_Get_Struct(tfval2, thread_frame_t, tf2);
+	if (Qtrue != frame_valid(tf2))
+	    rb_raise(rb_eFrameError, "invalid frame");
+
+	/* And just when you thought I'd never get around to the
+	   actual comparison...
+
+	   Comparing cfp's should be enough, but we'll throw in the thread
+	   for good measure.
+	*/
+	return (tf->th == tf2->th && tf->cfp == tf2->cfp)
+	    ? Qtrue : Qfalse;
+    }
+    /* NOTREACHED */
+    return Qnil;
+}
+
+/*
+ *  call-seq:
+ *     RubyVM::Frame.new(thread)          -> frame_object
+ *
+ *  Returns an RubyVM::Frame object which can contains dynamic frame
+ *  information. Don't use this directly. Instead use one of the
+ *  class methods.
+ *
+ *    RubyVM::Frame::current.flag          => 72
+ *    RubyVM::Frame::current.proc          => false
+ *    RubyVM::Frame::current.self          => 'main'
+ */
+static VALUE
+frame_initialize(VALUE tfval, VALUE thval)
+{
+    thread_frame_t *tf = frame_t_alloc(tfval);
+    GET_THREAD_PTR ;
+    memset(tf, 0, sizeof(thread_frame_t));
+    DATA_PTR(tfval) = tf;
+    SAVE_FRAME(tf, th) ;
+    return tfval;
+}
+
+/*
+ * call-seq:
+ *    RubyVM::Frame#valid? -> Boolean
+ *
+ * Returns true if the frame is no longer valid. On the other hand,
+ * since the test we use is weak, returning false might not mean the
+ * frame is valid, just that we can't disprove that it is not invalid.
+ *
+ * It is suggested that frames are used in a way that ensures they will
+ * be valid. In particular frames should have local scope and frames to
+ * threads other than the running one should be stopped while the frame
+ * variable is active.
+ */
+VALUE
+rb_frame_valid(VALUE klass)
+{
+    FRAME_SETUP ;
+    return frame_valid(tf);
+}
+
+VALUE
+rb_frame_return_stop_set(VALUE klass, VALUE boolval)
+{
+    short int boolmask = !(NIL_P(boolval) || Qfalse == boolval);
+    FRAME_SETUP_WITH_ERROR ;
+
+    if (boolmask)
+	tf->cfp->trace_disable |=  VM_FRAME_TRACE_RETURN;
+    else
+	tf->cfp->trace_disable &= ~VM_FRAME_TRACE_RETURN;
+    return boolval;
+}
+
+VALUE
+rb_frame_trace_off_set(VALUE klass, VALUE boolval)
+{
+    short int boolmask = !(NIL_P(boolval) || Qfalse == boolval);
+    FRAME_SETUP_WITH_ERROR ;
+
+    if (boolmask)
+	tf->cfp->trace_disable |=  VM_FRAME_TRACE_OFF;
+    else
+	tf->cfp->trace_disable &= ~VM_FRAME_TRACE_OFF;
+    return boolval;
+}
+
+VALUE
+rb_frame_trace_off_1_set(VALUE klass, VALUE boolval)
+{
+    short int boolmask = !(NIL_P(boolval) || Qfalse == boolval);
+    FRAME_SETUP_WITH_ERROR ;
+
+    if (boolmask)
+	tf->cfp->trace_disable |=  VM_FRAME_TRACE_OFF_1;
+    else
+	tf->cfp->trace_disable &= ~VM_FRAME_TRACE_OFF_1;
+    return boolval;
+}
+
+VALUE
+rb_frame_is_return_stop(VALUE klass)
+{
+    FRAME_SETUP_WITH_ERROR ;
+    return (tf->cfp->trace_disable & VM_FRAME_TRACE_RETURN) ?
+	Qtrue : Qfalse;
+}
+
+VALUE
+rb_frame_is_trace_off(VALUE klass)
+{
+    FRAME_SETUP_WITH_ERROR ;
+    return (tf->cfp->trace_disable & VM_FRAME_TRACE_OFF) ? Qtrue : Qfalse;
+}
+
+VALUE
+rb_frame_is_trace_off_1(VALUE klass)
+{
+    FRAME_SETUP_WITH_ERROR ;
+    return (tf->cfp->trace_disable & VM_FRAME_TRACE_OFF_1) ?
+	Qtrue : Qfalse;
+}
+
+/*
+ *  call-seq:
+ *     RubyVM::Frame#label  -> String or nil
+ *
+ * Returns the method associated with the frame or nil of none.
+ * FrameError can be raised if the threadframe
+ * object is no longer valid.
+ */
+VALUE
+rb_frame_label(VALUE klass)
+{
+    FRAME_SETUP_WITH_ERROR ;
+
+    switch (VM_FRAME_TYPE(tf->cfp)) {
+      case VM_FRAME_MAGIC_BLOCK:
+      case VM_FRAME_MAGIC_METHOD:
+	if (RUBY_VM_NORMAL_ISEQ_P(tf->cfp->iseq)) {
+	    return tf->cfp->iseq->location.label;
+	} else
+	    return Qnil;
+      case VM_FRAME_MAGIC_CFUNC: {
+	const char *method_name = rb_id2name(tf->cfp->me->def->original_id);
+	return (NULL == method_name) ? Qnil : rb_str_new2(method_name);
+      }
+      case VM_FRAME_MAGIC_EVAL:
+      case VM_FRAME_MAGIC_TOP:
+      case VM_FRAME_MAGIC_LAMBDA:
+      default:
+	return Qnil;
+    }
+    /* NOTREACHED */
+    return Qnil;
+}
+
+/*
+ *  call-seq:
+ *     RubyVM::Frame#method  -> String or nil
+ *
+ * Returns the method associated with the frame or nil of none.
+ * FrameError can be raised if the threadframe
+ * object is no longer valid.
+ */
+VALUE
+rb_frame_method(VALUE klass)
+{
+    FRAME_SETUP_WITH_ERROR ;
+
+    switch (VM_FRAME_TYPE(tf->cfp)) {
+      case VM_FRAME_MAGIC_METHOD:
+	if (RUBY_VM_NORMAL_ISEQ_P(tf->cfp->iseq)) {
+	    const char *method_name =
+		rb_id2name(tf->cfp->iseq->callinfo_entries->mid);
+	    rb_str_new2((NULL == method_name) ? "" : method_name );
+	} else
+	    return Qnil;
+      case VM_FRAME_MAGIC_CFUNC: {
+	const char *method_name = rb_id2name(tf->cfp->me->def->original_id);
+	return (NULL == method_name) ? Qnil : rb_str_new2(method_name);
+      }
+      case VM_FRAME_MAGIC_EVAL:
+      case VM_FRAME_MAGIC_TOP:
+      case VM_FRAME_MAGIC_BLOCK:
+      case VM_FRAME_MAGIC_LAMBDA:
+      default:
+	return Qnil;
+    }
+    /* NOTREACHED */
+    return Qnil;
+}
+
+/*
+ *  call-seq:
+ *     RubyVM::Frame#pc_offset  -> Fixnum
+ *
+ * Returns the offset inside the iseq or "program-counter offset" or -1
+ * If invalid/unstarted. FrameError can be raised if the threadframe
+ * object is no longer valid.
+ */
+VALUE
+rb_frame_pc_offset(VALUE klass)
+{
+    unsigned long pc;
+    FRAME_SETUP_WITH_ERROR ;
+
+    if (RUBY_VM_NORMAL_ISEQ_P(tf->cfp->iseq) &&
+	(tf->cfp->pc != 0 && tf->cfp->iseq != 0)) {
+	pc = tf->cfp->pc - tf->cfp->iseq->iseq_encoded;
+	return INT2FIX(pc);
+    } else {
+        return INT2FIX(-1);
+    }
+}
+
+/*
+ *  call-seq:
+ *     RubyVM::Frame#iseq           -> ISeq
+ *
+ *  Returns an instruction sequence object from the instruction sequence
+ *  found inside the Frame object or nil if there is none.
+ *
+ */
+VALUE
+rb_frame_iseq(VALUE klass)
+{
+    rb_iseq_t *iseq;
+    VALUE rb_iseq;
+    FRAME_SETUP_WITH_ERROR ;
+    iseq = tf->cfp->iseq;
+    if (!iseq) return Qnil;
+    rb_iseq = iseq_alloc_shared(rb_cISeq);
+    RDATA(rb_iseq)->data = iseq;
+    return rb_iseq;
+}
+
+#ifdef ROCKY_FIXED
+/*
+   See the above frame_prev comment for what's going on here.
+*/
+VALUE
+rb_frame_next(VALUE klass)
+{
+    rb_control_frame_t *cfp = NULL;
+    FRAME_SETUP_WITH_ERROR ;
+    cfp = RUBY_VM_NEXT_CONTROL_FRAME(tf->cfp);
+
+    if ((void *)(cfp) <= (void *)(tf->th->stack))
+        return Qnil;
+    else {
+        thread_frame_t *next_tf;
+        VALUE next = frame_alloc(rb_cFrame);
+	frame_t_alloc(next);
+	Data_Get_Struct(next, thread_frame_t, next_tf);
+	next_tf->th  = tf->th;
+	next_tf->cfp = cfp;
+	COPY_SIGNATURE(tf, cfp);
+	return next;
+    }
+}
+#endif
+
+/*
+ *  call-seq:
+ *     RubyVM::Frame#prev(n=1) -> frame_object
+ *
+ *  Returns a RubyVM::Frame object for the frame prior to the
+ *  Frame object or +nil+ if there is none. Setting n=0 just
+ *  returns the object passed.  A negative starts from the end. So
+ *  prev(-1) is the top frame.  Counts outside of the range
+ *  -stack_size .. stack_size-1 exceed the the range of the stack and
+ *  return nil.
+ *
+ */
+VALUE
+rb_frame_prev(int argc, VALUE *argv, VALUE klass)
+{
+    VALUE nv;
+    int n;
+
+    FRAME_SETUP_WITH_ERROR ;
+
+    rb_scan_args(argc, argv, "01", &nv);
+
+    if (Qnil == nv)
+	n = 1;
+    else if (!FIXNUM_P(nv)) {
+	rb_raise(rb_eTypeError, "integer argument expected");
+    } else
+	n = FIX2INT(nv);
+
+    if (n < 0) {
+      int stack_size = frame_stack_size(tf->cfp, tf->th);
+      if (-n > stack_size) return Qnil;
+      n = stack_size + n;
+    }
+    if (n == 0) return klass;
+    return frame_prev(tf->cfp, tf->th, n);
+}
+
+/*
+   See the above frame_prev comment for what's going on here.
+*/
+VALUE
+frame_prev(rb_control_frame_t *prev_cfp, rb_thread_t *th,
+			   int n)
+{
+  thread_frame_t *tf;
+  VALUE prev;
+  rb_control_frame_t *cfp = prev_cfp;
+
+  for (; n > 0; n--) {
+    cfp = prev_cfp;
+    prev_cfp = RUBY_VM_PREVIOUS_CONTROL_FRAME(cfp);
+    if (RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P(th, prev_cfp))
+	return Qnil;
+  }
+  if (!cfp) return Qnil;
+
+  prev = frame_alloc(rb_cFrame);
+  frame_t_alloc(prev);
+  Data_Get_Struct(prev, thread_frame_t, tf);
+  tf->th  = th;
+  tf->cfp = prev_cfp;
+  COPY_SIGNATURE(tf, tf->cfp);
+  return prev;
+}
+
+FRAME_FIELD_METHOD(klass) ;
+FRAME_FIELD_METHOD(proc) ;
+FRAME_FIELD_METHOD(self) ;
+
+#ifdef ROCKY_FIXED
+/*
+ *  call-seq:
+ *     RubyVM::Frame::current  -> frame_object
+ *
+ *  Returns a Frame object for the currently executing thread.
+ *  Same as: RubyVM::Frame.new(Thread::current)
+ */
+static VALUE
+frame_s_current(VALUE klass)
+{
+    thread_frame_t *tf = frame_t_alloc(klass);
+    rb_thread_t *th = ruby_current_thread;
+    rb_control_frame_t *start_cfp = RUBY_VM_END_CONTROL_FRAME(th);
+
+    /*                <- start_cfp (end control frame)
+     *  top frame (dummy)
+     *  top frame (dummy)
+     *  top frame     <- start_cfp
+     *  top frame
+     *  ...
+     *  2nd frame     <- lev:0
+     *  current frame <- th->cfp
+     */
+
+    start_cfp =
+      RUBY_VM_NEXT_CONTROL_FRAME(
+	  RUBY_VM_NEXT_CONTROL_FRAME(start_cfp)); /* skip top frames */
+
+    tf->th  = th;
+    tf->cfp = start_cfp;
+    COPY_SIGNATURE(tf, tf->cfp);
+    return Data_Wrap_Struct(klass, frame_mark, tf_free, tf);
+}
+#endif
+
+/*
+ *  call-seq:
+ *     RubyVM::Frame::get(thread)     -> RubyVM::Frame object
+ *     RubyVM::Frame::get(thread, n)  -> RubyVM::Frame object
+ *     RubyVM::Frame::get             -> RubyVM::Frame object
+ *     RubyVM::Frame::get(n)          -> RubyVM::Frame object
+ *
+ *  In the first form, we return the current RubyVM::Frame for the
+ *  Thread object passed. That is this is the current frame.
+ *
+ *  In the second form, we try to go back that many thread frames.
+ *
+ *  In the the third form, the current thread is assumed, and like the
+ *  first form get the current frame.
+ *
+ *  The fourth form, like the third form, we assume the current
+ *  thread.  And like the first form we go back we try to back a
+ *  FixNum number of entries.
+ *
+ *  When count +n+ is given 0 is synonymous with the previous frame
+ *  If the +n+ is negative, we count from the bottom
+ *  of the frame stack.
+ *
+ *  In all cases we return a RubyVM::Frame or nil if we can't
+ *  go back (or forward for a negative +n+) that many frames.
+ *
+ */
+static VALUE
+rb_frame_s_get(int argc, VALUE *argv, VALUE klass)
+{
+    VALUE first_val;
+    VALUE second_val;
+    int   prev_count = 0;
+    rb_thread_t *th = NULL;
+
+    /* Such complicated options processing. But we do want this
+       routine to be convenient. */
+    rb_scan_args(argc, argv, "02", &first_val, &second_val);
+    switch (argc) {
+      case 0:
+	th = ruby_current_thread;
+        /* Don't count the RubyVM::Frame.prev call */
+	prev_count = 1;
+	break;
+      case 1:
+	if (FIXNUM_P(first_val)) {
+	    prev_count = FIX2INT(first_val);
+	    if (prev_count >= 0) prev_count++ ;
+	    th = ruby_current_thread;
+	} else
+	    if (Qtrue == rb_obj_is_kind_of(first_val, rb_cThread)) {
+		GetThreadPtr(first_val, th);
+               /* Don't count the RubyVM::Frame.prev call */
+		prev_count = 1;
+	    } else {
+		rb_raise(rb_eTypeError,
+			 "FixNum or ThreadFrame object expected for first argument");
+	    }
+	break;
+      case 2:
+	if (Qtrue == rb_obj_is_kind_of(first_val, rb_cThread)) {
+	    GetThreadPtr(first_val, th);
+	} else {
+	    rb_raise(rb_eTypeError,
+		     "ThreadFrame object expected for first argument");
+	}
+	if (FIXNUM_P(second_val)) {
+	    prev_count = FIX2INT(second_val);
+	} else
+	    rb_raise(rb_eTypeError,
+		     "FixNum previous count expected for second argument");
+	break;
+      default:
+	rb_raise(rb_eArgError, "wrong number of arguments (%d for 1..2)", argc);
+    }
+
+    if (prev_count < 0) {
+      int stack_size = frame_stack_size(th->cfp, th);
+      if (-prev_count > stack_size) return Qnil;
+      prev_count = stack_size + prev_count;
+    }
+
+    return frame_prev(th->cfp, th, prev_count);
+}
+
+
+/*
+ *  call-seq:
+ *     RubyVM::Frame::stack_size -> FIXNUM
+ *
+ *  Get the frame stack size for the current thread.
+ *
+ */
+static VALUE
+rb_frame_s_stack_size(void)
+{
+    rb_thread_t *th = ruby_current_thread;
+    return INT2FIX(frame_stack_size(th->cfp, th));
+}
+
+
+/*
+ * call-seq:
+ *    RubyVM::Frame#source_container() -> [Type, String, [,String]]
+ *
+ * Returns a tuple representing kind of container, e.g. file
+ * eval'd string object, and the name of the container. If file,
+ * it would be a file name. If an eval'd string it might be the string.
+ * An optional 3rd argument files a full absolute path if it is a file.
+ */
+static VALUE
+frame_source_container(VALUE klass)
+{
+    VALUE path = Qnil;
+    VALUE abs_path = Qnil;
+    const char *contain_type;
+    rb_control_frame_t *cfp;
+    int is_eval = 0;
+
+    FRAME_SETUP_WITH_ERROR ;
+
+    cfp = tf->cfp;
+    if (RUBYVM_CFUNC_FRAME_P(cfp)) {
+	return rb_ary_new3(2, rb_str_new2("binary"),
+			   LONG2FIX(cfp->me->def->body.cfunc.func));
+    }
+
+    if (cfp->iseq) {
+	path = cfp->iseq->location.path;
+	abs_path = cfp->iseq->location.absolute_path;
+    } else {
+	if (tf->th->vm->progname)
+	    path = tf->th->vm->progname;
+	else
+	    return Qnil;
+    }
+
+    contain_type = source_container_type(path);
+
+    is_eval = ( 0 == strcmp("string", contain_type)
+		&& VM_FRAME_MAGIC_EVAL == VM_FRAME_TYPE(tf->cfp) );
+
+    if ( is_eval ) {
+	/* Try to pick up string from stack. */
+	VALUE prev = frame_prev(tf->cfp, tf->th, 1);
+	thread_frame_t *prev_tf;
+	Data_Get_Struct(prev, thread_frame_t, prev_tf);
+
+	if (RUBYVM_CFUNC_FRAME_P(prev_tf->cfp) &&
+	    frame_stack_size(prev_tf->cfp, prev_tf->th) >= 3)
+	    path = rb_frame_sp(prev, INT2FIX(3));
+    }
+
+    if (abs_path != Qnil)
+	return rb_ary_new3(3, rb_str_new2(contain_type), path, abs_path);
+    else
+	return rb_ary_new3(2, rb_str_new2(contain_type), path);
+}
+
+/*
+ * call-seq:
+ *    RubyVM::Frame#source_location() -> Array
+ *
+ * Returns an array of source location positions that match
+ * +tf.instruction_offset+. A source location position is left
+ * implementation dependent. It could be line number, a line number
+ * and start and end column, or a start line number, start column, end
+ * line number, end column.
+ */
+VALUE
+rb_frame_source_location(VALUE klass)
+{
+    rb_control_frame_t *cfp;
+    FRAME_SETUP_WITH_ERROR ;
+
+    /* For C frames we use the machine address of the function as the
+       location rather than the last Ruby source-code line as YARV
+       does. At a c_return event this is still not totally accurate,
+       but it is a more little accurate than YARV. The hope is that with
+       the address you have the *ability* to track things
+       further. gdb may be useful in tracking things further such as
+       with the "info symbol" command.
+    */
+    for ( cfp = tf->cfp; cfp && !cfp->iseq && RUBYVM_CFUNC_FRAME_P(cfp);
+	  cfp = RUBY_VM_PREVIOUS_CONTROL_FRAME(cfp) ) ;
+
+    if (RUBY_VM_NORMAL_ISEQ_P(cfp->iseq)) {
+	/* One thing YARV line locations do that foul us up is to
+	   treat the PC of a trace location as the previous instruction.
+	   Since we allow breakpoints on trace locations which happen *before*
+	   the trace is executed, we want to correct locations here.
+	*/
+	const rb_iseq_t *iseq = cfp->iseq;
+	size_t pos = cfp->pc - iseq->iseq_encoded;
+	VALUE insn = iseq->iseq[pos];
+	int is_trace = strncmp(insn_name(insn), "trace", sizeof("trace")) == 0;
+	if (is_trace) {
+	    /* printf("At trace instruction\n"); */
+	    pos++; /* Correct for subtraction in rb_iseq_line_no */
+	}
+	return rb_ary_new3(1, INT2FIX(rb_iseq_line_no(iseq, pos)));
+    } else
+	return Qnil;
+}
+
+/*
+ *  call-seq:
+ *     RubyVM::Frame#stack_size  -> Fixnum;
+ *
+ *  Returns a count of the number of frames including the current one.
+ *  Frame#prev(ThreadFrame#stack_size) = nil
+ *  Frame#prev(ThreadFrame#stack_size-1) = top frame
+ *
+ *
+ */
+static VALUE
+rb_frame_stack_size(VALUE klass)
+{
+    FRAME_SETUP ;
+    return INT2FIX(frame_stack_size(tf->cfp, tf->th));
+}
+
+/*
+   See the above frame_stack_size comment for what's going on here.
+*/
+static int
+frame_stack_size(rb_control_frame_t *cfp, rb_thread_t *th)
+{
+    int n;
+    for ( n = 0;
+	  !RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P(th, cfp);
+	  cfp = RUBY_VM_PREVIOUS_CONTROL_FRAME(cfp)) {
+	n++;
+    }
+    return n;
+}
+
+/*
+ *  call-seq:
+ *     RubyVM::Frame#thread   -> thread
+ *
+ *  Returns the thread object for the thread frame.
+ */
+VALUE
+rb_frame_thread(VALUE klass)
+{
+    FRAME_SETUP ;
+    return tf->th->self;
+}
+
+/* Extracted from vm_dump.c. Would be nice to have this routine put there
+   and used in both places. */
+static const char *
+frame_magic2str(rb_control_frame_t *cfp)
+{
+    switch (VM_FRAME_TYPE(cfp)) {
+      case VM_FRAME_MAGIC_METHOD:
+	return "METHOD";
+      case VM_FRAME_MAGIC_BLOCK:
+	return "BLOCK";
+      case VM_FRAME_MAGIC_CLASS:
+	return "CLASS";
+      case VM_FRAME_MAGIC_TOP:
+	return "TOP";
+      case VM_FRAME_MAGIC_CFUNC:
+	return "CFUNC";
+      case VM_FRAME_MAGIC_PROC:
+	return "PROC";
+      case VM_FRAME_MAGIC_IFUNC:
+	return "IFUNC";
+      case VM_FRAME_MAGIC_EVAL:
+	return "EVAL";
+      case VM_FRAME_MAGIC_LAMBDA:
+	return "LAMBDA";
+      case VM_FRAME_MAGIC_RESCUE:
+	return "RESCUE";
+      case 0:
+	return "------";
+      default:
+	return "(none)";
+    }
+    /* NOTREACHED */
+    return "?";
+}
+
+/*
+ *  call-seq:
+ *     Frame#type  -> String
+ *
+ * Returns the kind of frame. Basically interprets VM_FRAME_MAGIC for
+ * tf->cfp->flag
+ */
+static VALUE
+rb_frame_type(VALUE klass)
+{
+    FRAME_SETUP ;
+    return rb_str_new2(frame_magic2str(tf->cfp));
+}
+
+void
+Init_Frame(void)
+{
+    /* Additions to RubyVM */
+    rb_cFrame = rb_define_class_under(rb_cRubyVM, "Frame", rb_cObject);
+
+    /* RubyVM::Frame */
+    rb_define_alloc_func(rb_cFrame, frame_alloc);
+
+    rb_define_method(rb_cFrame, "valid?",       rb_frame_valid, 0);
+
+    rb_define_method(rb_cFrame, "binding",      rb_frame_binding, 0);
+    rb_define_method(rb_cFrame, "flag",         rb_frame_flag, 0);
+    rb_define_method(rb_cFrame, "initialize",   frame_initialize, 1);
+    rb_define_method(rb_cFrame, "klass",        rb_frame_klass, 0);
+    rb_define_method(rb_cFrame, "label",        rb_frame_label, 0);
+    rb_define_method(rb_cFrame, "method",       rb_frame_method, 0);
+    rb_define_method(rb_cFrame, "pc_offset",    rb_frame_pc_offset, 0);
+    rb_define_method(rb_cFrame, "prev",         rb_frame_prev, -1);
+    rb_define_method(rb_cFrame, "proc",         rb_frame_proc, 0);
+    rb_define_method(rb_cFrame, "self",         rb_frame_self, 0);
+    rb_define_method(rb_cFrame, "source_container",
+		     frame_source_container, 0);
+    rb_define_method(rb_cFrame, "source_location", rb_frame_source_location, 0);
+
+    /* sp[] and sp[]= would be neater, but that would require making sp an
+       object which I am not sure I want to do.
+     */
+    rb_define_method(rb_cFrame, "sp",           rb_frame_sp, 1);
+    rb_define_method(rb_cFrame, "sp_set",       rb_frame_sp_set, 2);
+    rb_define_method(rb_cFrame, "sp_size",      rb_frame_sp_size, 0);
+    rb_define_method(rb_cFrame, "ep",           rb_frame_ep, 0);
+    rb_define_method(rb_cFrame, "iseq",         rb_frame_iseq, 0);
+    /* I think I like the more explicit stack_size over size or length. */
+    rb_define_method(rb_cFrame, "stack_size",   rb_frame_stack_size, 0);
+#ifdef ROCKY_FIXED
+    rb_define_method(rb_cFrame, "next",         rb_frame_next, 0);
+#endif
+
+    rb_define_method(rb_cFrame, "return_stop=",
+		     rb_frame_return_stop_set, 1);
+    rb_define_method(rb_cFrame, "return_stop?",
+		     rb_frame_is_return_stop, 0);
+
+    rb_define_method(rb_cFrame, "thread",       rb_frame_thread, 0);
+    rb_define_method(rb_cFrame, "trace_off?",   rb_frame_is_trace_off, 0);
+    rb_define_method(rb_cFrame, "trace_off=",   rb_frame_trace_off_set, 1);
+    rb_define_method(rb_cFrame, "trace_off1?",  rb_frame_is_trace_off_1, 0);
+    rb_define_method(rb_cFrame, "trace_off1=",
+		     rb_frame_trace_off_1_set, 1);
+    rb_define_method(rb_cFrame, "type",         rb_frame_type, 0);
+
+    rb_define_method(rb_cFrame, "pc_offset=", frame_set_pc_offset, 1);
+    rb_eFrameError = rb_define_class("FrameError", rb_eStandardError);
+    rb_define_method(rb_cFrame, "equal?",     frame_equal, 1);
+
+    rb_define_singleton_method(rb_cFrame, "stack_size", rb_frame_s_stack_size, 0);
+    rb_define_singleton_method(rb_cFrame, "get", rb_frame_s_get, -1);
+}
diff --git a/inits.c b/inits.c
index 87c7505..d224923 100644
--- a/inits.c
+++ b/inits.c
@@ -56,6 +56,7 @@ rb_call_inits(void)
     CALL(VM);
     CALL(ISeq);
     CALL(Thread);
+    CALL(Frame);
     CALL(Cont);
     CALL(Rational);
     CALL(Complex);
diff --git a/test/debugger-ext/test-frame.rb b/test/debugger-ext/test-frame.rb
new file mode 100644
index 0000000..e9a4381
--- /dev/null
+++ b/test/debugger-ext/test-frame.rb
@@ -0,0 +1,162 @@
+require 'test/unit'
+
+class TestFrame < Test::Unit::TestCase
+
+    METHOD_TYPES = %w(METHOD BLOCK CLASS TOP CFUNC PROC IFUNC EVAL LAMBDA RESCUE)
+    def test_get
+        tf = RubyVM::Frame.get
+        count = tf.stack_size
+        assert_equal(caller_locations(0).size+1, count,
+                     "Should get same number of stack entries via caller(0).size")
+        count.times do |i|
+            caller_diff = caller_locations(0).size - count
+            cl = caller_locations(i+caller_diff)[0]
+            assert METHOD_TYPES.member?(tf.type)
+            if tf.source_container[0] == 'binary'
+                assert_equal('CFUNC', tf.type,
+                             "only C functions have container type binary")
+                assert_equal(tf.source_container[1], tf.source_location[0])
+            else
+                assert_equal(['file', cl.path], tf.source_container[0...-1],
+                             "location matching caller_locations at depth #{i}")
+                # source_location can be less than cl.lineno when cl_lineno
+                # we are stopped at a trace instruction.
+                # FIXME: either figure out how to remove the magic call stack numbers or
+                # change the test to be unconditionally <=
+                if [2,4,12,16,17,20,21].member?(i)
+                    assert cl.lineno <=  tf.source_location[0],
+                    "line number of caller_locations at depth #{i} for trace insn"
+                else
+                    assert_equal cl.lineno, tf.source_location[0],
+                    "line number of caller_locations at depth #{i}"
+                end
+            end
+
+            assert tf.valid? || tf.valid == nil
+
+            # FIXME: Binding.class SEGVs!
+            assert tf.binding, "Should get a binding back at depth #{i}"
+
+            # puts "Method: #{tf.method}"
+
+            # FIXME: bogus i > 0 and we should always be able to get a cl.label
+            assert_equal(cl.label, tf.label) if i > 0
+            # puts "Proc: #{tf.proc}"
+            # puts tf.self
+
+            # FIXME: stack size is the same for the 1st and 2nd iteration
+            # puts "Stack Size: #{tf.stack_size}"
+            assert_equal(count+1-i, tf.stack_size,
+                         "tf.stack size") if i > 0
+
+            # puts "Stack Pointer Size: #{tf.sp_size}"
+            # assert tf.iseq.kind_of?(Fixnum)
+            # FIXME tf.iseq.kind_of?(RubyVM::InstructionSequence) SEGVs
+            # in lookup up global constant. tf bolixed something.
+            assert tf.iseq || tf.type == 'CFUNC'
+            tf = tf.prev
+        end
+        assert_equal(tf.type, 'TOP',
+                     'Should get top-most frame')
+        tf = RubyVM::Frame.get
+    end
+
+    def test_sp
+        tf = RubyVM::Frame.get
+
+        assert tf.sp(1)
+        tf.sp_set(1, 5)
+        assert_equal(5, tf.sp(1), 'checking value of recently-set sp(1)')
+    end
+
+    def test_ep
+        tf = RubyVM::Frame.get
+        assert tf.ep
+    end
+
+    def test_fields(notused=nil)
+        tf = RubyVM::Frame::get
+        pc1 = tf.pc_offset
+        assert(pc1 > 0, 'Should be able to get a valid PC offset')
+        # pc_offset is dynamic - it changes constantly
+        pc2 = tf.pc_offset
+        assert(pc2 > pc1, 'PC offset should have changed (for the greater)')
+        assert_equal('test_fields', tf.method)
+        assert_equal(self, tf.self)
+        ## FIXME:
+        ## assert_equal(0, tf.arity)
+        ## assert_equal(0, tf.argc)
+
+        # assert_raises IndexError do
+        #   x = tf.lfp(tf.iseq.local_size+1)
+        # end
+
+
+        tf_prev = tf.prev
+        assert(tf_prev.pc_offset > 0, "Should be valid PC offset for prev")
+
+        # 1.times creates a C frame.
+        1.times do
+            tf = RubyVM::Frame::get
+            tup = tf.source_container
+            tup[1] = File.basename(tup[1])
+            assert_equal(nil, tf.method)
+            assert_equal('CFUNC', tf.prev.type)
+            assert_equal('times', tf.prev.method)
+            assert_equal(self, tf.self)
+            ## FIXME:
+            ## assert_equal(0, tf.get.arity, 'C arity should work nowadays' )
+            ## assert_equal(0, tf.get.argc, 'C args is the same as arity')
+            assert_equal('test_fields', tf.prev.prev.method)
+            ## FIXME:
+            ## assert_equal(0, tf.arity)
+            ## assert_equal(0, tf.argc)
+        end
+
+        # 1.upto also creates a C frame.
+        1.upto(1) do
+            tf = RubyVM::Frame::get.prev
+            assert_equal('CFUNC', tf.type)
+            # assert_equal(1, tf.arity, 'C arity should work nowadays' )
+            # assert_equal(1, tf.argc)
+        end
+
+        x  = lambda do |x,y|
+            frame = RubyVM::Frame::get
+            assert_equal(nil, frame.method)
+            assert_equal('LAMBDA', frame.type)
+            assert_equal(x, tf.self)
+            ## FIXME:
+            ## assert_equal(2, frame.arity)
+            ## assert_equal(2, frame.argc)
+        end
+        x.call(x,2)
+
+        x  = Proc.new do |x, y|
+            frame = RubyVM::Frame::get
+            assert_equal(nil, frame.method)
+            assert_equal(x, tf.self)
+            assert_equal('BLOCK', frame.type)
+        end
+        x.call(x,2)
+
+    end
+
+    def test_frame_equal
+        tf = RubyVM::Frame.get
+        tf2 = RubyVM::Frame.get
+        assert tf.equal?(tf)
+        assert tf.equal?(tf2)
+        assert tf.equal?(RubyVM::Frame.get(0))
+        tf2 = tf2.prev
+        assert tf2.equal?(RubyVM::Frame.get(1))
+        assert_equal(false, tf.equal?(tf2))
+        assert_raises TypeError do
+            tf.equal?(tf.iseq)
+        end
+    end
+end
+
+# We want to double-check we didn't mess up any pointers somewhere along
+# the line.
+at_exit { GC.start  }
diff --git a/test/debugger-ext/test_binding.rb b/test/debugger-ext/test_binding.rb
new file mode 100644
index 0000000..61a4dee
--- /dev/null
+++ b/test/debugger-ext/test_binding.rb
@@ -0,0 +1,43 @@
+require 'test/unit'
+
+def outside(a)
+    return eval('a', RubyVM::Frame.new(Thread::current).binding)
+end
+
+$a = 10
+
+class TestBinding < Test::Unit::TestCase
+  def test_basic
+    a = 1
+    c = 0
+    assert_equal(5, outside(5))
+    tf = RubyVM::Frame.new(Thread::current)
+    b  = tf.binding
+    assert_equal(1, eval('a', b))
+    assert_equal(10, eval('$a', b))
+    assert_equal(self, tf.self)
+    1.times do |i;a|
+      tf2 = RubyVM::Frame.get
+      b2  = tf2.binding
+      a = 2
+      assert_equal(2, eval('a', b2))
+      assert_equal(0, eval('c', b2))
+
+      # Times is C inline so prev we can't get a binding for it
+      # But we can for use the instruction sequence before that.
+      assert_equal(1, eval('a', tf2.prev(2).binding))
+    end
+    def inner(a)
+      tf3 = RubyVM::Frame.get
+      b3  = tf3.binding
+      if a == 4
+        assert_equal(4, eval('a', b3))
+        inner(a-1)
+      else
+        assert_equal(3, eval('a', b3))
+        assert_equal(4, eval('a', tf3.prev.binding))
+      end
+    end
+    inner(4)
+  end
+end
diff --git a/test/debugger-ext/test_frame_valid.rb b/test/debugger-ext/test_frame_valid.rb
new file mode 100644
index 0000000..fdad542
--- /dev/null
+++ b/test/debugger-ext/test_frame_valid.rb
@@ -0,0 +1,39 @@
+require 'test/unit'
+
+class TestInvalid < Test::Unit::TestCase
+  def test_basic
+    @tf = RubyVM::Frame::get
+    assert_equal(true, @tf.valid?,
+                 'Frame should be valid right after RubyVM::Frame::get')
+    def notgood(test_tf=nil)
+      # FIXME
+      # if test_tf
+      #   assert_equal(test_tf == @tf, test_tf.valid?)
+      # end
+      return RubyVM::Frame::get
+    end
+
+    def inner_fn(tf)
+      tf.valid?
+    end
+
+    invalid_tf = notgood
+    # FIXME:
+    # assert_equal(true, invalid_tf.invalid?,
+    #             'current thread frame should not be returned from a fn')
+    # begin
+    #   b = invalid_tf.binding
+    #   assert false, 'Should have raised an ThreadFrameError'
+    # rescue ThreadFrameError
+    #   assert true
+    # end
+    # Add a new local variable
+    x = 5
+    assert_equal(true, @tf.valid?,
+                 'Frame should still be valid after adding more locals')
+    assert_equal(true, inner_fn(@tf),
+                 'outer thread frame should ok inside a called fn')
+    notgood(invalid_tf)
+    notgood(@tf)
+  end
+end
diff --git a/test/debugger-ext/test_sp_size.rb b/test/debugger-ext/test_sp_size.rb
new file mode 100644
index 0000000..b330c3e
--- /dev/null
+++ b/test/debugger-ext/test_sp_size.rb
@@ -0,0 +1,42 @@
+require 'test/unit'
+
+# Test source_location and source_container.
+class TestSpSize < Test::Unit::TestCase
+
+  def sizes
+    tf = RubyVM::Frame::get
+    ary = []
+    0.upto(2) do |i|
+      ary << tf.sp_size
+      tf = tf.prev
+    end
+    # Swap first two items. The item that generally
+    # will vary is the a[0].
+    ary[0], ary[1] = ary[1], ary[0]
+    # p ary
+    return ary
+  end
+
+  def f0; return sizes end
+  def f1; a=1; return sizes end
+  def f1a(a) return sizes end
+  def f2(a,b) return sizes end
+
+  def test_sp_size
+    f0_s   = f0
+    f1_s   = f1
+    f1a_s  = f1a(1)
+    f2_s   = f2(1,2)
+    assert_equal(f0_s[0]+1,   f1_s[0])
+    assert_equal(f0_s[1..-1], f1_s[1..-1])
+    assert_equal(f1_s, f1a_s)
+    assert_equal(f1_s[0]+1,   f2_s[0])
+    assert_equal(f1_s[1..-1], f2_s[1..-1])
+
+    assert_raises ArgumentError do
+      tf = RubyVM::Frame.get
+      tf.sp_set(tf.sp_size, "Should not be able to set this.")
+    end
+  end
+
+end
diff --git a/vm_core.h b/vm_core.h
index dd89847..7904cd5 100644
--- a/vm_core.h
+++ b/vm_core.h
@@ -470,6 +470,9 @@ typedef struct rb_control_frame_struct {
     rb_iseq_t *block_iseq;	/* cfp[7] / block[3] */
     VALUE proc;			/* cfp[8] / block[4] */
     const rb_method_entry_t *me;/* cfp[9] */
+    short int trace_disable;    /* Bits to disable per-frame event tracing.
+				   See VM_FRAME_TRACE_xxx defines.
+				 */

 #if VM_DEBUG_BP_CHECK
     VALUE *bp_check;		/* cfp[10] */
@@ -792,6 +791,13 @@ enum vm_special_object_type {

 #define VM_FRAME_TYPE(cfp) ((cfp)->flag & VM_FRAME_MAGIC_MASK)

+#define VM_FRAME_TRACE_RETURN 0x01  /* Call trace hook on return. */
+#define VM_FRAME_TRACE_OFF    0x02  /* Turn of event hook tracing in this
+				       frame and any frames created from
+				       this one. */
+#define VM_FRAME_TRACE_OFF_1  0x04  /* Turn of event hook tracing in this
+				       frame only. */
+
 /* other frame flag */
 #define VM_FRAME_FLAG_PASSED  0x0100
 #define VM_FRAME_FLAG_FINISH  0x0200
diff --git a/test/debugger-ext/test-frame-disable.rb b/test/debugger-ext/test-frame-disable.rb
new file mode 100644
index 0000000..bf50412
--- /dev/null
+++ b/test/debugger-ext/test-frame-disable.rb
@@ -0,0 +1,48 @@
+require 'test/unit'
+
+class TestFrame < Test::Unit::TestCase
+
+    def five(a)
+        5
+    end
+    def test_frame_stop
+        @events = []
+        trace = TracePoint.new do |tp|
+            @events << tp.event
+        end
+        trace.enable
+        x = 1
+        five(10)
+        trace.disable
+        assert_equal false, @events.empty?
+        frame = RubyVM::Frame::get
+        assert_equal false, frame.trace_off?
+        # p @events
+        frame.trace_off = true
+        assert_equal true, frame.trace_off?
+        events_first = @events.dup
+        @events = []
+        trace.enable
+        x = 1
+        five(10)
+        trace.disable
+        # p @events
+        assert_equal [], @events
+        frame.trace_off1 = true
+        frame.trace_off = false
+        assert_equal true, frame.trace_off1?
+        assert_equal false, frame.trace_off?
+        trace.enable
+        x = 1
+        five(10)
+        trace.disable
+        # p @events
+        assert @events.size < events_first.size
+
+    end
+
+end
+
+# We want to double-check we didn't mess up any pointers somewhere along
+# the line.
+at_exit { GC.start  }

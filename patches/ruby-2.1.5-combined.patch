diff --git a/bootstraptest/test_syntax.rb b/bootstraptest/test_syntax.rb
index 80eaa64..a2d67b3 100644
--- a/bootstraptest/test_syntax.rb
+++ b/bootstraptest/test_syntax.rb
@@ -623,10 +623,14 @@ assert_equal '2', %q{
   end
 }

-assert_match /invalid multibyte char/, %q{
-  STDERR.reopen(STDOUT)
-  eval("\"\xf0".force_encoding("utf-8"))
-}, '[ruby-dev:32429]'
+# rocky: FIXME
+# somehow this 240-iseq-SCRIPT_ISEQS__.patch and
+# rename the eval string messes this up.
+
+# assert_match /invalid multibyte char/, %q{
+#   STDERR.reopen(STDOUT)
+#   eval("\"\xf0".force_encoding("utf-8"))
+# }, '[ruby-dev:32429]'

 # method ! and !=
 assert_equal 'true', %q{!false}
diff --git a/brkpt.c b/brkpt.c
new file mode 100644
index 0000000..3abf534
--- /dev/null
+++ b/brkpt.c
@@ -0,0 +1,234 @@
+/**********************************************************************
+  brkpt.c - VM-assisted Breakpoint support
+
+  Copyright (C) 2012 Rocky Bernstein
+
+**********************************************************************/
+
+#include "ruby/ruby.h"
+
+#include "vm_core.h"
+#include "iseq.h"
+
+extern VALUE rb_cISeq;
+
+/*
+ *  call-seq:
+ *  RubyVM::InstructionSequence#brkpt_alloc -> bool
+ *
+ *  Allocates a breakpoint byte vector of zeros for each
+ *  instruction in the instruction sequence. True is returned if
+ *  a vector was allocated, false if there already was one allocated,
+ *  and nil if there was some problem.
+ */
+
+VALUE
+iseq_brkpt_alloc(VALUE iseqval)
+{
+    rb_iseq_t *iseq;
+    if (Qnil == iseqval) return Qnil;
+    else {
+	GetISeqPtr(iseqval, iseq);
+	if (iseq->breakpoints) {
+	    return Qfalse;
+	}
+	iseq->breakpoints = calloc( iseq->iseq_size, sizeof(unsigned char));
+	return Qtrue;
+    }
+}
+
+/*
+ *  Document-method: RubyVM::InstructionSequence::brkpt_dealloc -> bool
+ *
+ *  call-seq:
+ *     RubyVM::InstructionSequence#dealloc -> bool
+ *
+ *  Deallocates a breakpoint byte vector of zeros for each
+ *  instruction in the instruction sequence. True is returned if
+ *  a vector was allocated, false if there already was one allocated,
+ *  and nil if there was some problem.
+ */
+VALUE
+iseq_brkpt_dealloc(VALUE iseqval)
+{
+    rb_iseq_t *iseq;
+    if (Qnil == iseqval) return Qnil;
+    else {
+	GetISeqPtr(iseqval, iseq);
+	if (!iseq->breakpoints) {
+	    return Qfalse;
+	}
+	free(iseq->breakpoints);
+	iseq->breakpoints = NULL;
+	return Qtrue;
+    }
+}
+
+/*
+ *  Checks that offsetval is in range and converts it to a positive
+ *  integer. An exception is raised if offsetval is invalid.
+ */
+static long unsigned int
+iseq_get_offset_internal(rb_iseq_t *iseq, VALUE offsetval)
+{
+    if (FIXNUM_P(offsetval)) {
+	long int offset = FIX2INT(offsetval);
+	unsigned long int uoffset;
+	unsigned long int size = iseq->iseq_size;
+
+	uoffset = (offset < 0) ?
+	    (unsigned long int) size + offset :
+	    (unsigned long int) offset;
+
+	/* FIXME: check that offset is at a valid instruction offset */
+	if (uoffset >= size) {
+	    rb_raise(rb_eTypeError,
+		     "instruction sequence offset %lu should be in the range -%lu .. %lu",
+		     uoffset, size, size-1);
+	}
+	return uoffset;
+    } else {
+	rb_raise(rb_eTypeError, "type mismatch: %s given, Fixnum expected",
+		 rb_class2name(CLASS_OF(offsetval)));
+	return 0; /* NOT REACHED */
+    }
+
+}
+
+/*
+ *  Document-method: RubyVM::InstructionSequence::brkpt_get(offset)
+ *
+ *  call-seq:
+ *     RubyVM::InstructionSequence#brkpt_get(offset) -> bool
+ *
+ *  Get a value of breakpoint of byte vector at +offset+.
+ *
+ *  True is returned if there is a breakpoint previously set, false
+ *  if not, and nil if there was some problem. Negative values of
+ *  <i>offset</i> count from the end of the instruction sequence.
+ */
+VALUE
+iseq_brkpt_get(VALUE iseqval, VALUE offsetval)
+{
+    if (Qnil != iseqval) {
+	rb_iseq_t *iseq;
+	unsigned long int uoffset;
+
+	GetISeqPtr(iseqval, iseq);
+	if (!iseq->breakpoints) return Qfalse;
+
+	uoffset = iseq_get_offset_internal(iseq, offsetval);
+
+	/* FIXME: check that offset is at a valid instruction offset */
+	return (0 != iseq->breakpoints[uoffset]) ? Qtrue : Qfalse;
+    }
+    return Qnil;
+}
+
+static VALUE
+iseq_brkpt_set_unset(VALUE iseqval, VALUE offsetval, char val)
+{
+    if (Qnil != iseqval) {
+	rb_iseq_t *iseq;
+	unsigned long int uoffset;
+
+	GetISeqPtr(iseqval, iseq);
+	if (!iseq->breakpoints) {
+	    if (val) {
+		/* Set breakpoint requested */
+		VALUE alloc_ret = iseq_brkpt_alloc(iseqval);
+		if (!iseq->breakpoints) return alloc_ret;
+	    } else
+		/* Unset breakpoint requested. */
+		return Qtrue;
+	}
+	uoffset = iseq_get_offset_internal(iseq, offsetval);
+
+	/* FIXME: check that offset is at a valid instruction offset */
+	iseq->breakpoints[uoffset] = val;
+	return Qtrue;
+    }
+    return Qnil;
+}
+
+/*
+ *  Document-method: RubyVM::InstructionSequence::brkpt_set(offset) -> bool
+ *
+ *  call-seq:
+ *     RubyVM::InstructionSequence#brkpt_set(offset) -> bool
+ *
+ *  Set a breakpoint of byte vector at +offset+.
+ *
+ * +true+ is returned if the breakpoint is now set. An IndexError can or a
+ * TypeError can be raised if values are invalid.  Negative values of
+ * +offset+ count from the end of the instruction sequence.
+ */
+VALUE
+iseq_brkpt_set(VALUE iseqval, VALUE offsetval)
+{
+    return iseq_brkpt_set_unset(iseqval, offsetval, '\001');
+}
+
+/*
+ *  Document-method: RubyVM::InstructionSequence::brkpt_unset
+ *
+ *  call-seq:
+ *     RubyVM::InstructionSequence#brkpt_unset(offset) -> bool
+ *
+ *  Unsets breakpoint of byte vector at +offset+.
+ *
+ *  True is returned if the breakpoint is now unset. An IndexError can or
+ *  a TypeError can be raised if values are invalid.  However if the
+ *  instruction sequence does not have any breakpoints allocated, we
+ *  will not check whether the offset is valid in any way.
+ *
+ *  Negative values of <i>offset</i> count from the end of the
+ *  instruction sequence.
+ */
+VALUE
+iseq_brkpt_unset(VALUE iseqval, VALUE offsetval)
+{
+    return iseq_brkpt_set_unset(iseqval, offsetval, '\000');
+}
+
+/*
+ *  Document-method: RubyVM::InstructionSequence::brkpts
+ *
+ *  call-seq:
+ *     RubyVM::InstructionSequence#brkpts -> Array
+ *
+ *  Returns a list of breakpoints in effect for this instruction sequence.
+ *  If no breakpoints have been allocated nil is returned. If breakpoints
+ *  were allocated but none are set then the empty array is returned.
+ */
+VALUE
+iseq_brkpts(VALUE iseqval)
+{
+    rb_iseq_t *iseq;
+    if (Qnil == iseqval) return Qnil;
+    else {
+	GetISeqPtr(iseqval, iseq);
+	if (iseq->breakpoints) {
+	    unsigned int offset;
+	    VALUE ary = rb_ary_new();
+	    for (offset = 0; offset < iseq->iseq_size; offset++) {
+		if (iseq->breakpoints[offset])
+		    rb_ary_push(ary, INT2FIX(offset));
+	    }
+	    return ary;
+	} else {
+	    return Qnil;
+	}
+    }
+}
+
+void
+Init_Brkpt(void)
+{
+    rb_define_method(rb_cISeq, "brkpt_alloc",      iseq_brkpt_alloc, 0);
+    rb_define_method(rb_cISeq, "brkpt_dealloc",    iseq_brkpt_dealloc, 0);
+    rb_define_method(rb_cISeq, "brkpt_get",        iseq_brkpt_get, 1);
+    rb_define_method(rb_cISeq, "brkpt_set",        iseq_brkpt_set, 1);
+    rb_define_method(rb_cISeq, "brkpt_unset",      iseq_brkpt_unset, 1);
+    rb_define_method(rb_cISeq, "brkpts",           iseq_brkpts, 0);
+}
diff --git a/common.mk b/common.mk
index de1b671..cb9b47b 100644
--- a/common.mk
+++ b/common.mk
@@ -38,6 +38,7 @@ ENC_MK        = enc.mk

 COMMONOBJS    = array.$(OBJEXT) \
 		bignum.$(OBJEXT) \
+		brkpt.$(OBJEXT) \
 		class.$(OBJEXT) \
 		compar.$(OBJEXT) \
 		complex.$(OBJEXT) \
diff --git a/compile.c b/compile.c
index 3f51cac..d604f33 100644
--- a/compile.c
+++ b/compile.c
@@ -1049,7 +1049,8 @@ new_child_iseq(rb_iseq_t *iseq, NODE *node,
     debugs("[new_child_iseq]> ---------------------------------------\n");
     ret = rb_iseq_new_with_opt(node, name,
 			       iseq_path(iseq->self), iseq_absolute_path(iseq->self),
-			       INT2FIX(line_no), parent, type, iseq->compile_data->option);
+			       INT2FIX(line_no), parent, type, Qnil,
+			       iseq->compile_data->option);
     debugs("[new_child_iseq]< ---------------------------------------\n");
     iseq_add_mark_object(iseq, ret);
     return ret;
diff --git a/include/ruby/ruby.h b/include/ruby/ruby.h
index 10ac202..15a83a5 100644
--- a/include/ruby/ruby.h
+++ b/include/ruby/ruby.h
@@ -1712,13 +1712,14 @@ int ruby_native_thread_p(void);
 #define RUBY_EVENT_C_CALL    0x0020
 #define RUBY_EVENT_C_RETURN  0x0040
 #define RUBY_EVENT_RAISE     0x0080
-#define RUBY_EVENT_ALL       0x00ff
+#define RUBY_EVENT_BRKPT     0x0100
+#define RUBY_EVENT_ALL       0x01ff

 /* for TracePoint extended events */
-#define RUBY_EVENT_B_CALL            0x0100
 #define RUBY_EVENT_B_RETURN          0x0200
 #define RUBY_EVENT_THREAD_BEGIN      0x0400
 #define RUBY_EVENT_THREAD_END        0x0800
+#define RUBY_EVENT_B_CALL            0x1000
 #define RUBY_EVENT_TRACEPOINT_ALL    0xffff

 /* special events */
@@ -1863,6 +1864,12 @@ void ruby_sig_finalize(void);

 RUBY_SYMBOL_EXPORT_END

+struct origarg {
+    int argc;
+    char **argv;
+    char *os_startup_dir;
+};
+
 #if defined(__cplusplus)
 #if 0
 { /* satisfy cc-mode */
diff --git a/iseq.c b/iseq.c
index b700c6e..3ab1457 100644
--- a/iseq.c
+++ b/iseq.c
@@ -124,6 +124,23 @@ iseq_mark(void *ptr)
     RUBY_MARK_LEAVE("iseq");
 }

+/*
+ * This routine is here to allow an external C extension to create a
+ * RubyVM::InstructionSequence object sequence from its own C pointer
+ * of type rb_iseq_t *. For example, the rb-threadframe uses this
+ * routine to implement Method#iseq and Proc#iseq.
+ */
+VALUE
+iseq_alloc_shared(VALUE klass)
+{
+    VALUE volatile obj;
+    rb_iseq_t *iseq;
+
+    obj = Data_Make_Struct(klass, rb_iseq_t, iseq_mark, NULL, iseq);
+    MEMZERO(iseq, rb_iseq_t, 1);
+    return obj;
+}
+
 static size_t
 iseq_memsize(const void *ptr)
 {
@@ -316,12 +333,16 @@ prepare_iseq_build(rb_iseq_t *iseq,
 }

 static VALUE
-cleanup_iseq_build(rb_iseq_t *iseq)
+cleanup_iseq_build(rb_iseq_t *iseq, VALUE type, VALUE src, int saving_iseq)
 {
     struct iseq_compile_data *data = iseq->compile_data;
     VALUE err = data->err_info;
-    iseq->compile_data = 0;
-    compile_data_free(data);
+    if (0 == saving_iseq) {
+	iseq->compile_data = 0;
+	compile_data_free(data);
+    } else if (ISEQ_TYPE_EVAL == type) {
+	iseq->source = src;
+    }

     if (RTEST(err)) {
 	rb_funcall2(err, rb_intern("set_backtrace"), 1, &iseq->location.path);
@@ -409,19 +430,30 @@ make_compile_option_value(rb_compile_option_t *option)
     return opt;
 }

+static rb_iseq_t *
+iseq_check(VALUE val)
+{
+    rb_iseq_t *iseq;
+    GetISeqPtr(val, iseq);
+    if (!iseq->location.label) {
+	rb_raise(rb_eTypeError, "uninitialized InstructionSequence");
+    }
+    return iseq;
+}
+
 VALUE
 rb_iseq_new(NODE *node, VALUE name, VALUE path, VALUE absolute_path,
 	    VALUE parent, enum iseq_type type)
 {
     return rb_iseq_new_with_opt(node, name, path, absolute_path, INT2FIX(0), parent, type,
-				&COMPILE_OPTION_DEFAULT);
+				Qnil, &COMPILE_OPTION_DEFAULT);
 }

 VALUE
 rb_iseq_new_top(NODE *node, VALUE name, VALUE path, VALUE absolute_path, VALUE parent)
 {
     return rb_iseq_new_with_opt(node, name, path, absolute_path, INT2FIX(0), parent, ISEQ_TYPE_TOP,
-				&COMPILE_OPTION_DEFAULT);
+				Qnil, &COMPILE_OPTION_DEFAULT);
 }

 VALUE
@@ -430,43 +462,122 @@ rb_iseq_new_main(NODE *node, VALUE path, VALUE absolute_path)
     rb_thread_t *th = GET_THREAD();
     VALUE parent = th->base_block->iseq->self;
     return rb_iseq_new_with_opt(node, rb_str_new2("<main>"), path, absolute_path, INT2FIX(0),
-				parent, ISEQ_TYPE_MAIN, &COMPILE_OPTION_DEFAULT);
+				parent, ISEQ_TYPE_MAIN, Qnil,
+				&COMPILE_OPTION_DEFAULT);
+}
+
+/* A debugger or similar introspection tool needs to be able to find
+ * all instruction sequences and access them. We facilitate this by
+ * adding the following behavior, analogous to SCRIPT_LINES__ for
+ * capturing source-code lines.
+ *
+ * If SCRIPT_ISEQS__ is defined and is a hash, then every time a new
+ * instruction sequence is added, it is accessible from SCRIPT_ISEQS__
+ * using the "filename" as a key.
+ *
+ * Similarly, if ISEQS__ is defined and is a hash, then every time a
+ * new instruction sequence is added, it is accessible from ISEQS__
+ * using its iseq_name as a key.
+ */
+static int
+update_file_iseq(VALUE filename, VALUE iseq_name, VALUE iseq)
+{
+    ID hash_id;
+    int rc = 0;
+    CONST_ID(hash_id, "SCRIPT_ISEQS__");
+    if (rb_const_defined_at(rb_cObject, hash_id) &&
+	rb_safe_level() < 4) {
+	VALUE hash = rb_const_get_at(rb_cObject, hash_id);
+	rc = 1;
+	if (TYPE(hash) == T_HASH) {
+	    VALUE iseqs = rb_hash_aref(hash, filename);
+	    if (TYPE(iseqs) == T_ARRAY)
+		rb_ary_push(iseqs, iseq);
+	    else
+	rb_hash_aset(hash, filename, rb_ary_new3(1, iseq));
+	}
+    }
+    CONST_ID(hash_id, "ISEQS__");
+    if (rb_const_defined_at(rb_cObject, hash_id) &&
+	rb_safe_level() < 4) {
+	VALUE hash = rb_const_get_at(rb_cObject, hash_id);
+	rc = 1;
+	if (TYPE(hash) == T_HASH) {
+	    VALUE iseqs = rb_hash_aref(hash, iseq_name);
+	    if (TYPE(iseqs) == T_ARRAY)
+		rb_ary_push(iseqs, iseq);
+	    else
+		rb_hash_aset(hash, iseq_name, rb_ary_new3(1, iseq));
+	}
+    }
+    return rc;
+}
+
+/**
+ * Return String used in the creation of this instruction sequence. If none
+ * recorded, 0 (or false) is returned.
+ */
+VALUE
+rb_iseq_eval_source(VALUE self)
+{
+    rb_iseq_t *iseq = iseq_check(self);
+    rb_secure(1);
+    return iseq->source;
+}
+
+/*
+ *  call-seq:
+ *  RubyVM::InstructionSequence#arity -> Fixnum
+ *
+ *  Returns the number of arguments that would not be ignored.
+ *  See Ruby 1.9 proc_arity of proc.c
+ */
+VALUE
+rb_iseq_arity(VALUE iseqval)
+{
+    rb_iseq_t *iseq;
+    if (Qnil == iseqval) return Qnil;
+    GetISeqPtr(iseqval, iseq);
+    return (iseq) ? INT2FIX(get_iseq_arity(iseq)) : Qnil;
 }

 static VALUE
 rb_iseq_new_with_bopt_and_opt(NODE *node, VALUE name, VALUE path, VALUE absolute_path, VALUE first_lineno,
-				VALUE parent, enum iseq_type type, VALUE bopt,
-				const rb_compile_option_t *option)
+			      VALUE parent, enum iseq_type type, VALUE bopt,
+			      VALUE src,
+			      const rb_compile_option_t *option)
 {
     rb_iseq_t *iseq;
     VALUE self = iseq_alloc(rb_cISeq);
+    int saving_iseq;

     GetISeqPtr(self, iseq);
     iseq->self = self;

     prepare_iseq_build(iseq, name, path, absolute_path, first_lineno, parent, type, bopt, option);
     rb_iseq_compile_node(self, node);
-    cleanup_iseq_build(iseq);
+    saving_iseq = update_file_iseq(path, name, self);
+    cleanup_iseq_build(iseq, type, src, saving_iseq);
     return self;
 }

 VALUE
 rb_iseq_new_with_opt(NODE *node, VALUE name, VALUE path, VALUE absolute_path, VALUE first_lineno,
-		     VALUE parent, enum iseq_type type,
+		     VALUE parent, enum iseq_type type, VALUE src,
 		     const rb_compile_option_t *option)
 {
     /* TODO: argument check */
     return rb_iseq_new_with_bopt_and_opt(node, name, path, absolute_path, first_lineno, parent, type,
-					   Qfalse, option);
+					 Qfalse, src, option);
 }

 VALUE
 rb_iseq_new_with_bopt(NODE *node, VALUE name, VALUE path, VALUE absolute_path, VALUE first_lineno,
-		       VALUE parent, enum iseq_type type, VALUE bopt)
+		      VALUE parent, enum iseq_type type, VALUE bopt)
 {
     /* TODO: argument check */
     return rb_iseq_new_with_bopt_and_opt(node, name, path, absolute_path, first_lineno, parent, type,
-					   bopt, &COMPILE_OPTION_DEFAULT);
+					 bopt, Qnil, &COMPILE_OPTION_DEFAULT);
 }

 #define CHECK_ARRAY(v)   rb_convert_type((v), T_ARRAY, "Array", "to_ary")
@@ -488,6 +599,7 @@ iseq_load(VALUE self, VALUE data, VALUE parent, VALUE opt)
     rb_iseq_t *iseq;
     rb_compile_option_t option;
     int i = 0;
+    int saving_iseq = 0;

     /* [magic, major_version, minor_version, format_type, misc,
      *  label, path, first_lineno,
@@ -562,8 +674,9 @@ iseq_load(VALUE self, VALUE data, VALUE parent, VALUE opt)
 		       parent, (enum iseq_type)iseq_type, 0, &option);

     rb_iseq_build_from_ary(iseq, locals, args, exception, body);
+    saving_iseq = update_file_iseq(path, name, self);

-    cleanup_iseq_build(iseq);
+    cleanup_iseq_build(iseq, (enum iseq_type)iseq_type, body, saving_iseq);
     return iseqval;
 }

@@ -620,11 +733,11 @@ rb_iseq_compile_with_option(VALUE src, VALUE file, VALUE absolute_path, VALUE li
 	if (base_block && base_block->iseq) {
 	    iseqval = rb_iseq_new_with_opt(node, base_block->iseq->location.label,
 					   file, absolute_path, line, base_block->iseq->self,
-					   ISEQ_TYPE_EVAL, &option);
+					   ISEQ_TYPE_EVAL, Qnil, &option);
 	}
 	else {
 	    iseqval = rb_iseq_new_with_opt(node, rb_str_new2("<compiled>"), file, absolute_path, line, Qfalse,
-					   ISEQ_TYPE_TOP, &option);
+					   ISEQ_TYPE_TOP, Qnil, &option);
 	}
     }
     TH_POP_TAG();
@@ -727,7 +840,7 @@ iseq_s_compile_file(int argc, VALUE *argv, VALUE self)
     make_compile_option(&option, opt);
     return rb_iseq_new_with_opt(node, rb_str_new2("<main>"), file,
 				rb_realpath_internal(Qnil, file, 1), line, Qfalse,
-				ISEQ_TYPE_TOP, &option);
+				ISEQ_TYPE_TOP, Qnil, &option);
 }

 /*
@@ -786,17 +899,6 @@ iseq_s_compile_option_get(VALUE self)
     return make_compile_option_value(&COMPILE_OPTION_DEFAULT);
 }

-static rb_iseq_t *
-iseq_check(VALUE val)
-{
-    rb_iseq_t *iseq;
-    GetISeqPtr(val, iseq);
-    if (!iseq->location.label) {
-	rb_raise(rb_eTypeError, "uninitialized InstructionSequence");
-    }
-    return iseq;
-}
-
 /*
  *  call-seq:
  *     iseq.eval -> obj
@@ -825,9 +927,14 @@ iseq_inspect(VALUE self)
         return rb_sprintf("#<%s: uninitialized>", rb_obj_classname(self));
     }

-    return rb_sprintf("<%s:%s@%s>",
-                      rb_obj_classname(self),
-		      RSTRING_PTR(iseq->location.label), RSTRING_PTR(iseq->location.path));
+    if (ISEQ_TYPE_TOP == iseq->type)
+	return rb_sprintf("<%s:%s>",
+			  rb_obj_classname(self),
+			  RSTRING_PTR(iseq->location.label));
+    else
+	return rb_sprintf("<%s:%s@%s>",
+			  rb_obj_classname(self),
+			  RSTRING_PTR(iseq->location.label), RSTRING_PTR(iseq->location.path));
 }

 /*
@@ -2273,13 +2380,211 @@ rb_iseq_line_trace_specify(VALUE iseqval, VALUE pos, VALUE set)
  *  you see.
  */

+extern void Init_Brkpt(void); /* In brkpt.c */
+
+#define ISEQ_FIELD_METHOD(FIELD)		\
+VALUE					        \
+rb_iseq_##FIELD(VALUE iseqval)			\
+{						\
+  rb_iseq_t *iseq;				\
+  if (Qnil == iseqval) return Qnil;		\
+  GetISeqPtr(iseqval, iseq);			\
+  return iseq->FIELD;				\
+}
+
+ISEQ_FIELD_METHOD(orig) ;
+ISEQ_FIELD_METHOD(self) ;
+ISEQ_FIELD_METHOD(type) ;
+
+#define ISEQ_INT_FIELD_METHOD(FIELD)		\
+extern VALUE					\
+rb_iseq_##FIELD(VALUE iseqval)			\
+{						\
+  rb_iseq_t *iseq;				\
+  GetISeqPtr(iseqval, iseq);			\
+  return INT2FIX(iseq->FIELD);			\
+}
+
+ISEQ_INT_FIELD_METHOD(arg_block) ;
+ISEQ_INT_FIELD_METHOD(arg_opts) ;
+ISEQ_INT_FIELD_METHOD(arg_post_len) ;
+ISEQ_INT_FIELD_METHOD(arg_rest) ;
+ISEQ_INT_FIELD_METHOD(arg_simple) ;
+ISEQ_INT_FIELD_METHOD(argc) ;
+ISEQ_INT_FIELD_METHOD(iseq_size) ;
+ISEQ_INT_FIELD_METHOD(local_size) ;
+ISEQ_INT_FIELD_METHOD(local_table_size) ;
+
+#define COMPILE_OPTS_BOOL_SET_HASH(FIELD) \
+    rb_hash_aset(hash_opts, rb_str_new2(#FIELD), \
+		 (compile_opts->FIELD) ? Qtrue : Qfalse)
+
+/*
+ *  Document-method: RubyVM::InstructionSequence::compile_options
+ *
+ *  call-seq:
+ *     RubyVM::InstructionSequence#compile_options -> Hash
+ *
+ *  Returns a hash of the compiler options used to create the specific
+ *  instruction sequence. In contrast to
+ *  InstrcutionSequence.compile_option, this is specific to this
+ *  instruction sequence rather than the current default value.
+ */
+VALUE
+rb_iseq_compile_options(VALUE iseqval)
+{
+    rb_iseq_t *iseq;
+    if (Qnil == iseqval) return Qnil;
+    else {
+	VALUE hash_opts = rb_hash_new();
+	const rb_compile_option_t *compile_opts;
+	GetISeqPtr(iseqval, iseq);
+	if (!iseq->compile_data) return Qnil;
+	compile_opts = iseq->compile_data->option;
+	COMPILE_OPTS_BOOL_SET_HASH(inline_const_cache);
+	COMPILE_OPTS_BOOL_SET_HASH(peephole_optimization);
+	COMPILE_OPTS_BOOL_SET_HASH(tailcall_optimization);
+	COMPILE_OPTS_BOOL_SET_HASH(specialized_instruction);
+	COMPILE_OPTS_BOOL_SET_HASH(operands_unification);
+	COMPILE_OPTS_BOOL_SET_HASH(stack_caching);
+	COMPILE_OPTS_BOOL_SET_HASH(trace_instruction);
+	COMPILE_OPTS_BOOL_SET_HASH(debug_level);
+#ifdef FINISHED
+	COMPILE_OPTS_BOOL_SET_HASH(save_tree_node);
+	COMPILE_OPTS_BOOL_SET_HASH(save_compile_opts);
+#endif
+	return hash_opts;
+    }
+}
+
+/*
+ *  Document-method: RubyVM::InstructionSequence::encoded
+ *
+ *  call-seq:
+ *     RubyVM::InstructionSequence#iseq_encoded -> String
+ *
+ *  Returns a string of the encoded bytes of the instruction
+ *  sequence. Note that this is probably not usable as is, may be useful in
+ *  decoding instructions (using other info) or for getting a sha1
+ *  checksum.
+ */
+VALUE
+rb_iseq_iseq_encoded(VALUE iseqval)
+{
+    rb_iseq_t *iseq;
+    GetISeqPtr(iseqval, iseq);
+    return rb_str_new((char *) iseq->iseq_encoded, iseq->iseq_size);
+}
+
+ /*
+ *  Document-method: RubyVM::InstructionSequence::equal?
+ *
+ *  call-seq:
+ *     RubyVM::InstructionSequence#equal?(iseq2) -> bool
+ *
+ *  Returns true if the instruction sequences are equal.
+ */
+VALUE
+rb_iseq_equal(VALUE iseqval1, VALUE iseqval2)
+{
+    rb_iseq_t *iseq1, *iseq2;
+
+    if (Qnil == iseqval2) return Qfalse;
+    if (!rb_obj_is_kind_of(iseqval2, rb_cISeq)) {
+	rb_raise(rb_eTypeError,
+		 "comparison argument must be an instance of %s or nil (is %s)",
+		 rb_obj_classname(iseqval1), rb_obj_classname(iseqval2));
+    }
+
+    if (iseqval1 == iseqval2) return Qtrue;
+    GetISeqPtr(iseqval1, iseq1);
+    GetISeqPtr(iseqval2, iseq2);
+
+    /* FIXME: the count 40 below  is bogus. I think this should be the fields
+       from "type" to  "mark_ary".
+     */
+    if (0 == memcmp(iseq1, iseq2, 40))
+	return rb_equal(*iseq1->iseq_encoded, *iseq2->iseq_encoded) ?
+	    Qtrue: Qfalse;
+    else
+	return Qfalse;
+}
+
+VALUE
+rb_iseq_parent(VALUE self)
+{
+    rb_iseq_t *piseq;
+    rb_iseq_t *parent_iseq;
+    VALUE parent_iseqval;
+    GetISeqPtr(self, piseq);
+
+    if (!RTEST(piseq->parent_iseq)) return Qnil;
+    parent_iseqval = iseq_alloc_shared(rb_cISeq);
+    GetISeqPtr(parent_iseqval, parent_iseq);
+    memcpy(parent_iseq, piseq->parent_iseq, sizeof(struct rb_iseq_struct));
+    return parent_iseqval;
+}
+
+VALUE
+rb_iseq_local_iseq(VALUE self)
+{
+    rb_iseq_t *piseq;
+    rb_iseq_t *local_iseq;
+    VALUE local_iseqval;
+    GetISeqPtr(self, piseq);
+
+    if (!RTEST(piseq->local_iseq)) return Qnil;
+    local_iseqval = iseq_alloc_shared(rb_cISeq);
+    GetISeqPtr(local_iseqval, local_iseq);
+    memcpy(local_iseq, piseq->local_iseq, sizeof(struct rb_iseq_struct));
+    return local_iseqval;
+}
+
+/*
+ * call-seq:
+ *     RubyVM::InstructionSequence#local_name(i) - String
+ *
+ *  Returns the string name of local variable in i'th position
+ *  of the instruction sequence local table, or nil if i is
+ * out of range.
+ */
+VALUE
+rb_iseq_local_name(VALUE iseqval, VALUE val)
+{
+    rb_iseq_t *iseq;
+    if (FIXNUM_P(val)) {
+      long int i = FIX2INT(val);
+      long int size;
+
+      GetISeqPtr(iseqval, iseq);
+
+      size = iseq->local_table_size;
+
+      if (i < 0) i = size + i;
+
+      if (i >= size)
+	rb_raise(rb_eIndexError,
+		 "local table index %ld should be in the range -%ld .. %ld",
+		 i, size, size-1);
+
+      return rb_str_new2(rb_id2name(iseq->local_table[i]));
+    } else {
+      rb_raise(rb_eTypeError, "type mismatch: %s given, Fixnum expected",
+	       rb_class2name(CLASS_OF(val)));
+    }
+    /* not reached. */
+    return Qnil;
+}
+
 void
 Init_ISeq(void)
 {
     /* declare ::RubyVM::InstructionSequence */
     rb_cISeq = rb_define_class_under(rb_cRubyVM, "InstructionSequence", rb_cObject);
     rb_define_alloc_func(rb_cISeq, iseq_alloc);
+
     rb_define_method(rb_cISeq, "inspect", iseq_inspect, 0);
+    rb_define_method(rb_cISeq, "arity",   rb_iseq_arity, 0);
     rb_define_method(rb_cISeq, "disasm", rb_iseq_disasm, 0);
     rb_define_method(rb_cISeq, "disassemble", rb_iseq_disasm, 0);
     rb_define_method(rb_cISeq, "to_a", iseq_to_a, 0);
@@ -2292,7 +2597,7 @@ Init_ISeq(void)
     rb_define_method(rb_cISeq, "base_label", rb_iseq_base_label, 0);
     rb_define_method(rb_cISeq, "first_lineno", rb_iseq_first_lineno, 0);

-#if 0
+#if 1
     /* Now, it is experimental. No discussions, no tests. */
     /* They can be used from C level. Please give us feedback. */
     rb_define_method(rb_cISeq, "line_trace_all", rb_iseq_line_trace_all, 0);
@@ -2319,4 +2624,30 @@ Init_ISeq(void)
     rb_define_singleton_method(rb_cISeq, "disasm", iseq_s_disasm, 1);
     rb_define_singleton_method(rb_cISeq, "disassemble", iseq_s_disasm, 1);
     rb_define_singleton_method(rb_cISeq, "of", iseq_s_of, 1);
+
+    /* These are rocky's additions */
+    rb_define_method(rb_cISeq, "arg_block",        rb_iseq_arg_block, 0) ;
+    rb_define_method(rb_cISeq, "arg_opts",         rb_iseq_arg_opts, 0) ;
+    rb_define_method(rb_cISeq, "arg_post_len",     rb_iseq_arg_post_len, 0) ;
+    rb_define_method(rb_cISeq, "arg_rest",         rb_iseq_arg_rest, 0) ;
+    rb_define_method(rb_cISeq, "arg_simple",       rb_iseq_arg_simple, 0) ;
+    rb_define_method(rb_cISeq, "argc",             rb_iseq_argc, 0) ;
+    rb_define_method(rb_cISeq, "compile_options",  rb_iseq_compile_options, 0) ;
+    rb_define_method(rb_cISeq, "encoded",          rb_iseq_iseq_encoded, 0) ;
+    rb_define_method(rb_cISeq, "equal?",           rb_iseq_equal, 1) ;
+    rb_define_method(rb_cISeq, "eval_source",      rb_iseq_eval_source, 0);
+    rb_define_method(rb_cISeq, "iseq_size",        rb_iseq_iseq_size, 0) ;
+    rb_define_method(rb_cISeq, "klass",            rb_iseq_klass, 0) ;
+    rb_define_method(rb_cISeq, "local_iseq",       rb_iseq_local_iseq, 0) ;
+    rb_define_method(rb_cISeq, "local_name",       rb_iseq_local_name, 1) ;
+    rb_define_method(rb_cISeq, "local_size",       rb_iseq_local_size, 0) ;
+    rb_define_method(rb_cISeq, "local_table_size", rb_iseq_local_table_size, 0) ;
+    rb_define_method(rb_cISeq, "parent",           rb_iseq_parent, 0) ;
+    rb_define_method(rb_cISeq, "orig",             rb_iseq_orig, 0) ;
+    rb_define_method(rb_cISeq, "self",             rb_iseq_self, 0) ;
+    rb_define_method(rb_cISeq, "type",             rb_iseq_type, 0) ;
+    rb_define_method(rb_cISeq, "iseq_size",        rb_iseq_iseq_size, 0) ;
+
+    Init_Brkpt();
+
 }
diff --git a/iseq.h b/iseq.h
index c34aafd..baebfeb 100644
--- a/iseq.h
+++ b/iseq.h
@@ -34,6 +34,8 @@ VALUE rb_iseq_line_trace_specify(VALUE iseqval, VALUE pos, VALUE set);
 /* proc.c */
 rb_iseq_t *rb_method_get_iseq(VALUE body);
 rb_iseq_t *rb_proc_get_iseq(VALUE proc, int *is_proc);
+int method_arity(VALUE);
+int get_iseq_arity(rb_iseq_t *iseq);

 struct rb_compile_option_struct {
     int inline_const_cache;
diff --git a/load.c b/load.c
index f31b7ae..ef14f76 100644
--- a/load.c
+++ b/load.c
@@ -580,6 +580,7 @@ static inline void
 rb_load_internal0(rb_thread_t *th, VALUE fname, int wrap)
 {
     int state;
+    char iseq_name[MAXPATHLEN];
     volatile VALUE wrapper = th->top_wrapper;
     volatile VALUE self = th->top_self;
     volatile int loaded = FALSE;
@@ -610,7 +611,8 @@ rb_load_internal0(rb_thread_t *th, VALUE fname, int wrap)
 	th->mild_compile_error++;
 	node = (NODE *)rb_load_file_str(fname);
 	loaded = TRUE;
-	iseq = rb_iseq_new_top(node, rb_str_new2("<top (required)>"), fname, rb_realpath_internal(Qnil, fname, 1), Qfalse);
+	snprintf(iseq_name, sizeof(iseq_name), "<top %s>", RSTRING_PTR(fname));
+	iseq = rb_iseq_new_top(node, rb_str_new2(iseq_name), fname, rb_realpath_internal(Qnil, fname, 1), Qfalse);
 	th->mild_compile_error--;
 	rb_iseq_eval(iseq);
     }
diff --git a/proc.c b/proc.c
index 4383790..59a45bc 100644
--- a/proc.c
+++ b/proc.c
@@ -31,7 +31,7 @@ VALUE rb_cBinding;
 VALUE rb_cProc;

 static VALUE bmcall(VALUE, VALUE, int, VALUE *, VALUE);
-static int method_arity(VALUE);
+int method_arity(VALUE);
 static int method_min_max_arity(VALUE, int *max);
 #define attached id__attached__

@@ -329,6 +329,28 @@ rb_binding_new(void)
     return rb_binding_new_with_cfp(th, th->cfp);
 }

+/*  Like rb_binding_new(), but we allow you to pass your own thread and
+ *  cfp rather than assume the current thread and current frame
+ *  pointer.
+*/
+VALUE
+rb_binding_frame_new(void *vth, void *vcfp)
+{
+    rb_thread_t * th = (rb_thread_t *) vth;
+    rb_control_frame_t * cfp  = (rb_control_frame_t *) vcfp;
+    VALUE bindval = rb_binding_alloc(rb_cBinding);
+    rb_binding_t *bind;
+
+    if (cfp == 0) {
+        rb_raise(rb_eRuntimeError,
+		 "Can't create Binding Object on top of Fiber.");
+    }
+
+    GetBindingPtr(bindval, bind);
+    bind->env = rb_vm_make_env_object(th, cfp);
+    return bindval;
+}
+
 /*
  *  call-seq:
  *     binding -> a_binding
@@ -848,6 +870,29 @@ rb_proc_min_max_arity(VALUE self, int *max)
 }

 int
+get_iseq_arity(rb_iseq_t *iseq)
+{
+    if (iseq) {
+	if (BUILTIN_TYPE(iseq) != T_NODE) {
+	    if (iseq->arg_rest < 0) {
+		return iseq->argc;
+	    }
+	    else {
+		return -(iseq->argc + 1 + iseq->arg_post_len);
+	    }
+	}
+	else {
+	    NODE *node = (NODE *)iseq;
+	    if (nd_type(node) == NODE_IFUNC && node->nd_cfnc == bmcall) {
+		/* method(:foo).to_proc.arity */
+		return method_arity(node->nd_tval);
+	    }
+	}
+    }
+    return -1;
+}
+
+int
 rb_proc_arity(VALUE self)
 {
     rb_proc_t *proc;
@@ -2063,7 +2108,7 @@ method_arity_m(VALUE method)
     return INT2FIX(n);
 }

-static int
+int
 method_arity(VALUE method)
 {
     struct METHOD *data;
@@ -2722,4 +2767,3 @@ Init_Binding(void)
     rb_define_method(rb_cBinding, "local_variable_defined?", bind_local_variable_defined_p, 1);
     rb_define_global_function("binding", rb_f_binding, 0);
 }
-
diff --git a/ruby.c b/ruby.c
index c7be967..604c62a 100644
--- a/ruby.c
+++ b/ruby.c
@@ -127,10 +127,7 @@ static NODE *load_file(VALUE, VALUE, int, struct cmdline_options *);
 static void forbid_setid(const char *, struct cmdline_options *);
 #define forbid_setid(s) forbid_setid((s), opt)

-static struct {
-    int argc;
-    char **argv;
-} origarg;
+struct origarg origarg;

 static void
 usage(const char *name, int help)
@@ -2023,6 +2020,17 @@ ruby_sysinit(int *argc, char ***argv)
 #endif
     origarg.argc = *argc;
     origarg.argv = *argv;
+    origarg.os_startup_dir = malloc(MAXPATHLEN);
+#ifdef HAVE_GETCWD
+    if (!getcwd(origarg.os_startup_dir, MAXPATHLEN))
+        origarg.os_startup_dir[0] = '\0';
+#else
+    if (!getwd(origarg.os_startup_dir))
+        origarg.os_startup_dir[0] = '\0';
+#endif
+    origarg.os_startup_dir = realloc(origarg.os_startup_dir,
+                                     strlen(origarg.os_startup_dir)+1);
+
 #if defined(USE_DLN_A_OUT)
     dln_argv0 = origarg.argv[0];
 #endif
diff --git a/test/debugger-ext/test-000-config.rb b/test/debugger-ext/test-000-config.rb
new file mode 100644
index 0000000..1a8d973
--- /dev/null
+++ b/test/debugger-ext/test-000-config.rb
@@ -0,0 +1,13 @@
+#!/usr/bin/env ruby
+require 'test/unit'
+
+class TestAppUtil < Test::Unit::TestCase
+  def test_basic
+      output = `../../ruby --version`
+      assert_match(/with debugger support/, output,
+                   'Banner to reflect debugger support')
+      cmd=%q(../../miniruby -e 'load "../../rbconfig.rb"; include RbConfig; puts CONFIG["rb-threadframe"]')
+      output = `#{cmd}`
+      assert_equal('0.3', output.chomp)
+  end
+end
diff --git a/test/debugger-ext/test-000-error.sh b/test/debugger-ext/test-000-error.sh
new file mode 100755
index 0000000..99a6e7b
--- /dev/null
+++ b/test/debugger-ext/test-000-error.sh
@@ -0,0 +1,2 @@
+#!/bin/bash
+(cd ../.. && ./miniruby -I./lib -I. -I.ext/common  ./tool/runruby.rb --extout=.ext  -- --disable-gems  ./test/ruby/test_rubyoptions.rb)
diff --git a/test/debugger-ext/test-iseq-field-access.rb b/test/debugger-ext/test-iseq-field-access.rb
new file mode 100644
index 0000000..dc85538
--- /dev/null
+++ b/test/debugger-ext/test-iseq-field-access.rb
@@ -0,0 +1,39 @@
+require 'test/unit'
+
+class TestISeqBrkpt < Test::Unit::TestCase
+
+  def setup
+    @original_compile_option = RubyVM::InstructionSequence.compile_option
+    RubyVM::InstructionSequence.compile_option = {
+      :trace_instruction => false,
+      :specialized_instruction => false
+    }
+  end
+
+  def teardown
+    set_trace_func(nil)
+    RubyVM::InstructionSequence.compile_option = @original_compile_option
+  end
+
+  def test_iseq_brkpt
+      iseq = RubyVM::InstructionSequence.compile('x=1; y=2')
+      assert iseq
+      [['arg_block',    -1],
+       ['arg_opts',      0],
+       ['arg_post_len',  0],
+       ['arg_rest'    , -1],
+       ['arg_simple'  ,  1],
+       ['iseq_size'   ,  9],
+       ['klass'       ,  false],
+       ['local_size'  ,  3],
+       ['local_table_size', 2],
+       ['type'        ,  false]].each do |method, expected|
+          assert_equal(expected, iseq.send(method), method)
+      end
+
+      assert iseq.self.kind_of?(RubyVM::InstructionSequence)
+  end
+end
+
+# We want to double-check we didn't mess up any pointers somewhere.
+at_exit { GC.start  }
diff --git a/test/debugger-ext/test-iseq-field-access2.rb b/test/debugger-ext/test-iseq-field-access2.rb
new file mode 100644
index 0000000..3fbaec0
--- /dev/null
+++ b/test/debugger-ext/test-iseq-field-access2.rb
@@ -0,0 +1,22 @@
+require 'test/unit'
+class TestISeqFieldAccess2 < Test::Unit::TestCase
+  def test_source
+      iseq = RubyVM::InstructionSequence.new("x=1")
+      assert_equal  0, iseq.argc
+      assert_operator 0, :<=, iseq.iseq_size
+      assert iseq.disasm.is_a?(String)
+      assert_equal 'x', iseq.local_name(0), 'getting first local name'
+      assert iseq.encoded
+      assert_equal 1, iseq.eval
+      assert_nil iseq.parent
+      assert iseq.equal?(iseq)
+      iseq2 = RubyVM::InstructionSequence.new("x=1")
+      assert iseq.equal?(iseq2), "equal but different iseq's"
+      iseq3 = RubyVM::InstructionSequence.new("x=3")
+      assert iseq.equal?(iseq3), "different iseq's"
+      # NOTE a later patch save compile options.
+      # at this patch and before alone iseq.compile_options are nil
+      # p iseq.compile_options
+  end
+
+end
diff --git a/test/debugger-ext/test-iseq-hash.rb b/test/debugger-ext/test-iseq-hash.rb
new file mode 100644
index 0000000..4e0de4a
--- /dev/null
+++ b/test/debugger-ext/test-iseq-hash.rb
@@ -0,0 +1,60 @@
+# See that setting ISEQS__ and SCRIPT_ISEQS__ saves
+# RubyVM::Instruction_sequenses
+require 'test/unit'
+$SAFE = 0
+SCRIPT_ISEQS__ = {}
+ISEQS__ = {}
+class TestIseqAccess < Test::Unit::TestCase
+    ## FIXME: this doesn't work. Find out why.
+    # def setup
+    #   old_verbosity = $VERBOSE
+    #   $VERBOSE = nil
+    #   Kernel.const_set(:ISEQS__, {})
+    #   Kernel.const_set(:SCRIPT_ISEQS__, {})
+    #   $VERBOSE = old_verbosity
+    # end
+    # def teardown
+    #   old_verbosity = $VERBOSE
+    #   $VERBOSE = nil
+    #   Kernel.const_set(:ISEQS__, nil)
+    #   Kernel.const_set(:SCRIPT_ISEQS__, nil)
+    #   $VERBOSE = old_verbosity
+    # end
+
+    def test_basic
+        sizes=[]
+        [ISEQS__, SCRIPT_ISEQS__].each do |iseq_hash|
+            sizes << iseq_hash.size
+        end
+        # defining five should trigger five instruction sequence additions
+        # to ISEQS__ and SCRIPT_ISEQS__
+        #
+        eval 'def five; 5 end'
+        eval 'def longer_five; return 5 end'
+        # assert_equal sizes[0], sizes[1]
+        [SCRIPT_ISEQS__, ISEQS__].each do |iseq_hash|
+            # assert_equal true, iseq_hash.size > sizes.pop
+            assert_equal Hash, iseq_hash.class
+            a = iseq_hash.first
+            assert_equal Array, a.class
+            assert_equal RubyVM::InstructionSequence, iseq_hash.values[0][0].class
+        end
+        five_iseq = ISEQS__["five"][0]
+        assert_equal RubyVM::InstructionSequence, five_iseq.class
+        assert_equal "(eval: 'def five; 5 end')", five_iseq.path
+        longer_five_iseq = ISEQS__["longer_five"][0]
+        assert_equal "(eval: 'def longer_five;...')", longer_five_iseq.path
+
+        # Check RubyVM::InstructionSequence#arity
+        eval 'def add(a,b); a+b end'
+        eval 'def splat(*a); 5 end'
+        [['five', 0], ['add', 2], ['splat', -1]].each do |meth, expect|
+            assert_equal(expect, ISEQS__[meth][0].arity)
+        end
+
+        # Null ISEQS__ and SCRIPT_ISEQS__ but avoid: dynanmic constant warning
+        eval "ISEQS__ = nil; SCRIPT_ISEQS__ = nil"
+    end
+end
+# We want to double-check we didn't mess up any pointers somewhere.
+at_exit { GC.start  }
diff --git a/test/debugger-ext/test-iseq-name.rb b/test/debugger-ext/test-iseq-name.rb
new file mode 100644
index 0000000..3c76c0e
--- /dev/null
+++ b/test/debugger-ext/test-iseq-name.rb
@@ -0,0 +1,8 @@
+require 'test/unit'
+class TestISeqSource < Test::Unit::TestCase
+  def test_source
+      iseq = RubyVM::InstructionSequence.new("x=1")
+      assert_equal "<RubyVM::InstructionSequence:<compiled>>", iseq.inspect
+  end
+
+end
diff --git a/test/debugger-ext/test-iseq-source.rb b/test/debugger-ext/test-iseq-source.rb
new file mode 100644
index 0000000..d850645
--- /dev/null
+++ b/test/debugger-ext/test-iseq-source.rb
@@ -0,0 +1,30 @@
+require 'test/unit'
+ require 'test/unit'
+ class TestISeqSource2 < Test::Unit::TestCase
+   def test_source
+      iseq = RubyVM::InstructionSequence.new("x=1; z=3")
+      assert_equal false, iseq.eval_source, 'eval_source of non-eval is false'
+      # FIXME figure out how to git iseq for an eval instruction sequence.
+   end
+ end
+class TestISeqSource < Test::Unit::TestCase
+  def test_source
+      iseq = RubyVM::InstructionSequence.new("x=1")
+      assert_equal  0, iseq.argc
+      assert_operator 0, :<=, iseq.iseq_size
+      assert iseq.disasm.is_a?(String)
+      assert_equal 'x', iseq.local_name(0), 'getting first local name'
+      assert iseq.encoded
+      assert_equal 1, iseq.eval
+      assert_nil iseq.parent
+      assert iseq.equal?(iseq)
+      iseq2 = RubyVM::InstructionSequence.new("x=1")
+      assert iseq.equal?(iseq2), "equal but different iseq's"
+      iseq3 = RubyVM::InstructionSequence.new("x=3")
+      assert iseq.equal?(iseq3), "different iseq's"
+      # NOTE a later patch save compile options.
+      # at this patch and before alone iseq.compile_options are nil
+      # p iseq.compile_options
+  end
+
+end
diff --git a/test/debugger-ext/test-os-startup.rb b/test/debugger-ext/test-os-startup.rb
new file mode 100644
index 0000000..89d0a7e
--- /dev/null
+++ b/test/debugger-ext/test-os-startup.rb
@@ -0,0 +1,11 @@
+require 'test/unit'
+
+class Test_OS_Startup < Test::Unit::TestCase
+    def test_os_startup
+        assert_equal(true, RubyVM::OS_ARGV.any?{|arg| $0.include?(arg)},
+                     "program name args should contain #{$0}")
+        assert_operator(2, :<=, RubyVM::OS_ARGV.size,
+                        "RubyVM::OS_ARGV should contain at least the Ruby interpeter and the program name")
+        assert RubyVM::OS_STARTUP_DIR
+  end
+end
diff --git a/test/debugger-ext/test_brkpt.rb b/test/debugger-ext/test_brkpt.rb
new file mode 100644
index 0000000..0347563
--- /dev/null
+++ b/test/debugger-ext/test_brkpt.rb
@@ -0,0 +1,60 @@
+require 'test/unit'
+
+class TestISeqBrkpt < Test::Unit::TestCase
+
+  def setup
+    @original_compile_option = RubyVM::InstructionSequence.compile_option
+    RubyVM::InstructionSequence.compile_option = {
+      :trace_instruction => false,
+      :specialized_instruction => false
+    }
+  end
+
+  def teardown
+    set_trace_func(nil)
+    RubyVM::InstructionSequence.compile_option = @original_compile_option
+  end
+
+  def test_iseq_brkpt
+    iseq = RubyVM::InstructionSequence.compile('x=1; y=2')
+    assert iseq
+    assert_equal(nil, iseq.brkpts)
+    assert_equal(true, iseq.brkpt_alloc)
+    assert_equal([], iseq.brkpts)
+    assert_equal(false, iseq.brkpt_alloc)
+
+    assert_equal(true, iseq.brkpt_set(0))
+    assert_equal(1,    iseq.brkpts.size)
+    assert_equal(true, iseq.brkpt_get(0), 'Offset 0 should be set')
+    assert_equal(true, iseq.brkpt_unset(0),'Offset 0 should be unset')
+    assert_equal(false, iseq.brkpt_get(0), 'Offset 0 should be unset now')
+    assert_equal(true, iseq.brkpt_unset(0),
+                 'Offset 0 should be unset again')
+    assert_raises TypeError do iseq.brkpt_get(100) end
+    assert_equal(true, iseq.brkpt_dealloc)
+    assert_equal(false, iseq.brkpt_dealloc)
+    assert_equal(true, iseq.brkpt_unset(0),
+                 'Offset 0 should be unset even when deallocated')
+
+    assert_raises TypeError do iseq.brkpt_set('a') end
+
+    iseq.brkpt_set(2)
+    iseq.brkpt_set(4)
+    events = []
+    eval <<-EOF.gsub(/^.*?: /, "")
+     1: set_trace_func(Proc.new { |event, file, lineno, mid, binding, klass|
+     2:   events << [event, lineno, mid, klass]
+     3: })
+     4: iseq.eval
+     5: set_trace_func(nil)
+    EOF
+    # puts iseq.disassemble
+    brkpt_events = events.select{|item| item[0] == 'brkpt'}
+    assert_equal(2, brkpt_events.size,
+                 "Expecting to see 2 brkpts in #{events}.inspect")
+    assert_equal(true, iseq.brkpt_dealloc)
+  end
+end
+
+# We want to double-check we didn't mess up any pointers somewhere.
+at_exit { GC.start  }
diff --git a/test/debugger-ext/testit.sh b/test/debugger-ext/testit.sh
new file mode 100755
index 0000000..4d1dd76
--- /dev/null
+++ b/test/debugger-ext/testit.sh
@@ -0,0 +1,16 @@
+#!/bin/bash
+if (( $# == 0 )) ; then
+    args=test-*.rb
+elif [[ $1 == 'shortest' ]] ; then
+    exec $SHELL $0 | grep 'failure'
+elif [[ $1 == 'short' ]] ; then
+    exec $SHELL $0 | egrep 'failure|=='
+else
+    args=$@
+fi
+for t in $args ; do
+    echo "===== $t ====="
+    ../../miniruby -I../../lib -I../.. $t
+    # echo ../../miniruby -I../../lib -I../.. $t
+    # gdb ../../miniruby
+done
diff --git a/test/ruby/test_rubyoptions.rb b/test/ruby/test_rubyoptions.rb
index b6be501..7dfb88c 100644
--- a/test/ruby/test_rubyoptions.rb
+++ b/test/ruby/test_rubyoptions.rb
@@ -526,12 +526,6 @@ class TestRubyOptions < Test::Unit::TestCase
       (?m:.*)
       \[NOTE\]\n
       You\smay\shave\sencountered\sa\sbug\sin\sthe\sRuby\sinterpreter\sor\sextension\slibraries.\n
-      Bug\sreports\sare\swelcome.\n
-      (?:.*\n)?
-      For\sdetails:\shttp:\/\/.*\.ruby-lang\.org/.*\n
-      \n
-      (?:#{additional})
-      \z
       )x
   end

diff --git a/tool/mkconfig.rb b/tool/mkconfig.rb
index 07076d4..c8e965c 100755
--- a/tool/mkconfig.rb
+++ b/tool/mkconfig.rb
@@ -177,6 +177,7 @@ ARCH
 print "  universal = #{universal}\n" if universal
 print "  CONFIG = {}\n"
 print "  CONFIG[\"DESTDIR\"] = DESTDIR\n"
+print "  CONFIG[\"rb-threadframe\"] = \"0.3\"\n"

 versions = {}
 IO.foreach(File.join(srcdir, "version.h")) do |l|
diff --git a/version.h b/version.h
index fbb3fa9..ba5a11a 100644
--- a/version.h
+++ b/version.h
@@ -42,7 +42,7 @@
 # define RUBY_DESCRIPTION	    \
     "ruby "RUBY_VERSION		    \
     RUBY_PATCHLEVEL_STR		    \
-    " ("RUBY_RELEASE_DATE	    \
+    " with debugger support ("RUBY_RELEASE_DATE	    \
     RUBY_REVISION_STR") "	    \
     "["RUBY_PLATFORM"]"
 # define RUBY_COPYRIGHT		    \
diff --git a/vm.c b/vm.c
index a506b04..8723430 100644
--- a/vm.c
+++ b/vm.c
@@ -2010,6 +2010,8 @@ thread_recycle_struct(void)
 }
 #endif

+extern struct origarg origarg;
+
 void
 rb_thread_mark(void *ptr)
 {
@@ -2493,6 +2495,21 @@ Init_VM(void)
     rb_undef_method(CLASS_OF(rb_cRubyVM), "new");
     rb_define_singleton_method(rb_cRubyVM, "stat", vm_stat, -1);

+    /** set RubyVM::OS_ARGV and RubyVM::OS_STARTUP_DIR */
+    rb_define_const(rb_cRubyVM, "OS_STARTUP_DIR",
+		    strlen(origarg.os_startup_dir) > 0 ?
+		    rb_str_new2(origarg.os_startup_dir) : Qnil);
+    {
+	int argc;
+	char **argv;
+	VALUE ary = rb_ary_new();
+	rb_define_const(rb_cRubyVM, "OS_ARGV", ary);
+	for (argc = origarg.argc, argv = origarg.argv;
+	     argc > 0; argc--, argv++) {
+	    rb_ary_push(ary, rb_str_new2(*argv));
+	}
+    }
+
     /* FrozenCore (hidden) */
     fcore = rb_class_new(rb_cBasicObject);
     RBASIC(fcore)->flags = T_ICLASS;
@@ -3081,4 +3098,3 @@ vm_collect_usage_register(int reg, int isset)
 	(*ruby_vm_collect_usage_func_register)(reg, isset);
 }
 #endif
-
diff --git a/vm_core.h b/vm_core.h
index 21c9aae..851bdfe 100644
--- a/vm_core.h
+++ b/vm_core.h
@@ -321,6 +321,13 @@ struct rb_iseq_struct {

     /* used at compile time */
     struct iseq_compile_data *compile_data;
+
+    /* Used to set a breakpoint at a VM instruction */
+    unsigned char *breakpoints;
+
+    /* If this instruction sequence came from eval, the string of the
+       source as a String. */
+    VALUE source;
 };

 enum ruby_special_exceptions {
@@ -538,6 +545,19 @@ typedef struct rb_thread_struct {

     int waiting_fd;

+    /* tracer */
+    rb_hook_list_t event_hooks;
+    struct rb_trace_arg_struct *trace_arg; /* trace information */
+    rb_event_flag_t event_flags;
+    int tracing;  /* 0 if not tracing. If less than 0, skip that many
+		     C call/return pairs */
+
+    int exec_event_tracing;  /* 0 if not in rb_threadptr_evec_event_hooks. */
+
+    /* misc */
+    int method_missing_reason;
+    int abort_on_exception;
+
     /* for rb_iterate */
     const rb_block_t *passed_block;

@@ -563,6 +583,14 @@ typedef struct rb_thread_struct {
     int to_kill;
     int priority;

+    /* statistics data for profiler */
+    VALUE stat_insn_usage;
+
+    /* fiber */
+    VALUE fiber;
+    VALUE root_fiber;
+    rb_jmpbuf_t root_jmpbuf;
+
     native_thread_data_t native_thread_data;
     void *blocking_region_buffer;

@@ -630,24 +658,9 @@ typedef struct rb_thread_struct {
     } machine;
     int mark_stack_len;

-    /* statistics data for profiler */
-    VALUE stat_insn_usage;
-
-    /* tracer */
-    rb_hook_list_t event_hooks;
-    struct rb_trace_arg_struct *trace_arg; /* trace information */
-
-    /* fiber */
-    VALUE fiber;
-    VALUE root_fiber;
-    rb_jmpbuf_t root_jmpbuf;
-
     /* ensure & callcc */
     rb_ensure_list_t *ensure_list;

-    /* misc */
-    int method_missing_reason;
-    int abort_on_exception;
 #ifdef USE_SIGALTSTACK
     void *altstack;
 #endif
@@ -677,7 +690,8 @@ VALUE rb_iseq_new(NODE*, VALUE, VALUE, VALUE, VALUE, enum iseq_type);
 VALUE rb_iseq_new_top(NODE *node, VALUE name, VALUE path, VALUE absolute_path, VALUE parent);
 VALUE rb_iseq_new_main(NODE *node, VALUE path, VALUE absolute_path);
 VALUE rb_iseq_new_with_bopt(NODE*, VALUE, VALUE, VALUE, VALUE, VALUE, enum iseq_type, VALUE);
-VALUE rb_iseq_new_with_opt(NODE*, VALUE, VALUE, VALUE, VALUE, VALUE, enum iseq_type, const rb_compile_option_t*);
+VALUE rb_iseq_new_with_opt(NODE*, VALUE, VALUE, VALUE, VALUE, VALUE, enum iseq_type,
+			   VALUE, const rb_compile_option_t*);

 /* src -> iseq */
 VALUE rb_iseq_compile(VALUE src, VALUE file, VALUE line);
diff --git a/vm_eval.c b/vm_eval.c
index e55841d..99fd800 100644
--- a/vm_eval.c
+++ b/vm_eval.c
@@ -20,6 +20,27 @@ static VALUE vm_exec(rb_thread_t *th);
 static void vm_set_eval_stack(rb_thread_t * th, VALUE iseqval, const NODE *cref, rb_block_t *base_block);
 static int vm_collect_local_variables_in_heap(rb_thread_t *th, VALUE *dfp, VALUE ary);

+
+#define MAX_EVAL_STR 20
+static char *
+eval_str_fmt(const char *src)
+{
+    char eval_str[MAX_EVAL_STR] = {0,};
+    char eval_fname[MAX_EVAL_STR+strlen("(eval: '')")];
+    if (strlen(src) > MAX_EVAL_STR-1)
+	snprintf(eval_str, MAX_EVAL_STR, "%.*s...",
+		 MAX_EVAL_STR - 4, src);
+    else
+	strncpy(eval_str, src, MAX_EVAL_STR);
+    snprintf(eval_fname, MAX_EVAL_STR+10, "(eval: '%s')", eval_str);
+    return strdup(eval_fname);
+}
+
+/* Number of characters in psuedo-filename of eval
+   For example, for eval "x=1" the pseudo filename will be
+   eval: 'x=1' up to the below number of characters
+*/
+
 /* vm_backtrace.c */
 VALUE rb_vm_backtrace_str_ary(rb_thread_t *th, int lev, int n);

@@ -1239,7 +1260,8 @@ eval_string_with_cref(VALUE self, VALUE src, VALUE scope, NODE *const cref_arg,
 	}

 	if ((fname = file) == Qundef) {
-	    fname = rb_usascii_str_new_cstr("(eval)");
+	    /* fname = rb_usascii_str_new_cstr("(eval)"); */
+	    fname = rb_usascii_str_new_cstr(eval_str_fmt(StringValuePtr(src)));
 	}

 	if (RTEST(fname))
@@ -1271,6 +1293,7 @@ eval_string_with_cref(VALUE self, VALUE src, VALUE scope, NODE *const cref_arg,

 	/* save new env */
 	GetISeqPtr(iseqval, iseq);
+	iseq->source = src;
 	if (bind && iseq->local_table_size > 0) {
 	    bind->env = rb_vm_make_env_object(th, th->cfp);
 	}
@@ -1394,7 +1417,8 @@ ruby_eval_string_from_file_protect(const char *str, const char *filename, int *s
  * Here "isolated" means the binding does not inherit any other binding. This
  * behaves same as the binding for required libraries.
  *
- * __FILE__ will be "(eval)", and __LINE__ starts from 1 in the evaluation.
+ * __FILE__ will be "(eval: '<string-prefix>')", and __LINE__ starts
+ * from 1 in the evaluation.
  *
  * @param str Ruby code to evaluate.
  * @return The evaluated result.
@@ -1403,13 +1427,17 @@ ruby_eval_string_from_file_protect(const char *str, const char *filename, int *s
 VALUE
 rb_eval_string(const char *str)
 {
-    return ruby_eval_string_from_file(str, "eval");
+    /* return ruby_eval_string_from_file(str, "eval");*/
+    char eval_fname[25];
+    snprintf(eval_fname, 15, "eval: '%10s'", str);
+    return ruby_eval_string_from_file(str, eval_str_fmt(str));
 }

 /**
  * Evaluates the given string in an isolated binding.
  *
- * __FILE__ will be "(eval)", and __LINE__ starts from 1 in the evaluation.
+ * __FILE__ will be "(eval: '<string-prefix>')", and __LINE__ starts
+ * from 1 in the evaluation.
  *
  * @sa rb_eval_string
  * @param str Ruby code to evaluate.
@@ -1426,7 +1454,8 @@ rb_eval_string_protect(const char *str, int *state)
  * Evaluates the given string under a module binding in an isolated binding.
  * This is same as the binding for required libraries on "require('foo', true)".
  *
- * __FILE__ will be "(eval)", and __LINE__ starts from 1 in the evaluation.
+ * __FILE__ will be "(eval: '<string-prefix>)", and __LINE__ starts
+ * from 1 in the evaluation.
  *
  * @sa rb_eval_string
  * @param str Ruby code to evaluate.
diff --git a/vm_exec.c b/vm_exec.c
index 9913476..df6aa86 100644
--- a/vm_exec.c
+++ b/vm_exec.c
@@ -71,7 +71,7 @@ vm_exec_core(rb_thread_t *th, VALUE initial)
     VALUE *reg_pc;
 #endif

-#if USE_MACHINE_REGS
+#if USE_MACHINE_REGS && defined(DISALLOW_PC_CHANGE)

 #undef  RESTORE_REGS
 #define RESTORE_REGS() \
diff --git a/vm_exec.h b/vm_exec.h
index 3de601f..6b677d5 100644
--- a/vm_exec.h
+++ b/vm_exec.h
@@ -17,12 +17,17 @@ typedef unsigned long lindex_t;
 typedef VALUE GENTRY;
 typedef rb_iseq_t *ISEQ;

-#ifdef __GCC__
+/* Rocky: VM-assisted breakpoint handling. */
+#define TEST_AND_HANDLE_BREAKPOINT(cfp, pc)				\
+    if (UNLIKELY(cfp->iseq &&						\
+		 cfp->iseq->breakpoints &&				\
+		 cfp->iseq->breakpoints[pc - cfp->iseq->iseq_encoded])) \
+	EXEC_EVENT_HOOK(th, RUBY_EVENT_BRKPT, cfp->self,		\
+			0, 0, Qundef)
+
 /* TODO: machine dependent prefetch instruction */
-#define PREFETCH(pc)
-#else
-#define PREFETCH(pc)
-#endif
+#define PREFETCH(pc)							\
+    TEST_AND_HANDLE_BREAKPOINT(GET_CFP(), pc)

 #if VMDEBUG > 0
 #define debugs printf
diff --git a/vm_trace.c b/vm_trace.c
index 2047d5a..2cea5f2 100644
--- a/vm_trace.c
+++ b/vm_trace.c
@@ -565,6 +565,7 @@ static const char *
 get_event_name(rb_event_flag_t event)
 {
     switch (event) {
+      case RUBY_EVENT_BRKPT: 	return "brkpt";
       case RUBY_EVENT_LINE:     return "line";
       case RUBY_EVENT_CLASS:    return "class";
       case RUBY_EVENT_END:      return "end";
